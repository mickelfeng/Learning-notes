# 动态代理

> Java中可以利用反射实现动态代理。不过由于使用了反射机制，效率较低。

## 代码范例

```kotlin
fun <T> create(service: Class<T>): T {
  return Proxy.newProxyInstance(
    service.classLoader,
    arrayOf<Class<*>>(service)
  ) { proxy, method, args ->
     // InvocationHandler 符合SAM转换要求，这里直接简化了
     val annotations = method.annotations
     for (annotation in annotations) {
       if (annotation is GET) {
         val url = baseUrl + annotation.value
         return@newProxyInstance invoke(url, method, args!!)
       }
     }
     return@newProxyInstance null

    } as T
}

private fun invoke(path: String, method: Method, args: Array<Any>): Any? {
  if (method.parameterAnnotations.size != args.size) return null

  var url = path
  val parameterAnnotations = method.parameterAnnotations
  for (i in parameterAnnotations.indices) {
    for (parameterAnnotation in parameterAnnotations[i]) {
      if (parameterAnnotation is Field) {
        val key = parameterAnnotation.value
        val value = args[i].toString()
        if (!url.contains("?")) {
          url += "?$key=$value"
        } else {
          url += "&$key=$value"
        }

      }
    }
  }

  val request = Request.Builder()
  .url(url)
  .build()

  val response = okHttpClient.newCall(request).execute()

  val genericReturnType = method.genericReturnType
  val body = response.body
  val json = body?.string()
  val result = gson.fromJson<Any?>(json, genericReturnType)

  return result
}
```

## 代码分析

* 通过 `Proxy.newProxyInstance()` 函数，构建 class 对应的类实例。

```java
public class Proxy implements java.io.Serializable {
  
 
  @CallerSensitive
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
        throws IllegalArgumentException
    {
        Objects.requireNonNull(h);

        final Class<?>[] intfs = interfaces.clone();
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        /*
         * Look up or generate the designated proxy class.
         */
        Class<?> cl = getProxyClass0(loader, intfs);

        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                hrow new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }
}
```



#### InvocationHandler

* method：对应你**调用的接口函数**。
* args：传入的**参数数组**。

```java
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}

```

