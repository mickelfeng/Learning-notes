# Java动态代理

## JDK动态代理

JDK动态代理是**基于反射实现接口的动态代理**，执行效率较低。

* 通过 `Proxy.newProxyInstance()` 反射生成一个匿名代理类，这个代理持有了 `InvocationHandler`，调用方法时会通过它来回调。
* 我们可以在  `InvocationHandler.invoke()` 中来处理方法调用。

### 代码范例

```kotlin
fun <T> create(service: Class<T>): T {
  return Proxy.newProxyInstance(
    service.classLoader,
    arrayOf<Class<*>>(service)
  ) { proxy, method, args ->
     // InvocationHandler 符合SAM转换要求，这里直接简化了
     val annotations = method.annotations
     for (annotation in annotations) {
       if (annotation is GET) {
         val url = baseUrl + annotation.value
         return@newProxyInstance invoke(url, method, args!!)
       }
     }
     return@newProxyInstance null
    } as T
}

private fun invoke(path: String, method: Method, args: Array<Any>): Any? {
  if (method.parameterAnnotations.size != args.size) return null

  var url = path
  val parameterAnnotations = method.parameterAnnotations
  for (i in parameterAnnotations.indices) {
    for (parameterAnnotation in parameterAnnotations[i]) {
      if (parameterAnnotation is Field) {
        val key = parameterAnnotation.value
        val value = args[i].toString()
        if (!url.contains("?")) {
          url += "?$key=$value"
        } else {
          url += "&$key=$value"
        }

      }
    }
  }

  val request = Request.Builder()
  .url(url)
  .build()

  val response = okHttpClient.newCall(request).execute()

  val genericReturnType = method.genericReturnType
  val body = response.body
  val json = body?.string()
  val result = gson.fromJson<Any?>(json, genericReturnType)

  return result
}
```

### 代码分析

#### Proxy

* 通过 `Proxy.newProxyInstance()` 函数，构建 class 对应的类实例。

```java
public class Proxy implements java.io.Serializable {
  
  @CallerSensitive
    public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
        throws IllegalArgumentException
    {
        Objects.requireNonNull(h);

        final Class<?>[] intfs = interfaces.clone();
        final SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        /*
         * Look up or generate the designated proxy class.
         */
        Class<?> cl = getProxyClass0(loader, intfs);

        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                hrow new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }
}
```

#### InvocationHandler

* method：对应你**调用的接口函数**。
* args：传入的**参数数组**。

```java
public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}

```



## CGLIB 动态代理

CGLIB动态代理是**基于ASM字节码生成框架实现的**，可以在运行时对字节码进行修改和动态生成。

使用了 `FastClass` 机制来优化方法的调用速度，它会为每个类生成一个索引数组，根据索引号直接定位到要调用的方法。

* 它会创建一个继承目标类的子类，然后重写所有非final的方法。若是final则无法使用CGLIB动态代理。
* 使用Enhancer类作为增强器，通过它可以设置目标类、拦截器并创建代理对象。
* 在`MethodInterceptor.intercept()`中用于实现方法增强逻辑。
