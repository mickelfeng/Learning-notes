# 对象创建过程

## 对象类型

- 普通Java对象
- 数组
- Class对象

## 创建方式

- 通常使用``new``关键字：调用构造器来初始化实例字段。
- `Object.clone`复制：直接复制已有的数据。
- 反序列化：直接复制已有的数据。
- `Unsafe.allocateInstance`：没有初始化实例字段。

## 对象创建过程

### 1. 类加载检查

首先需要找到类，然后执行**类加载**。

* JVM虚拟机接收到 `new` 指令。
* 检查指令的参数是否能在运行时常量池中找到对应类的符号引用。
* 检查这个符号引用代表的类是否已经被加载过。即类加载的三个过程：加载、连接、初始化。
* 若未加载则执行类加载流程。

### 2. 分配内存

通过第一步的类加载检查后，JVM就会给对象**分配内存**。

从Java堆中分配一块指定大小的内存给对象实例。根据堆的内存是否规整存在两种分配方式：**指针碰撞（内存规整）**、**空闲列表（内存不规则）**。

### 3. 初始化零值

当内存分配完成后，虚拟机会将这块分配的内存空间都初始化为零值（除对象头），其实就是 将java对象的字段默认初始为零值（对应类型的初始值）。

### 4. 设置对象头

接着虚拟机会对对象设置一些必要的信息，存放在对象头中。主要包括三个部分：MarkWord、元数据指针、数组数据（数组对象才有）。

其中MarkWord比较复杂，包括： 对象的HashCode、对象所属年代、对象锁、偏向锁等等。

![img](./%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.assets/1748585-20230525094258181-1639554907.png)

### 5. 执行init方法初始化

执行完 上面几个步骤，虚拟机的工作基本已经完成了，不过此时所有字段都还是null， 所以需要执行初始化：调用 `init()`函数。

这个方法会**根据我们设置的初始值来为字段赋值**。初始化完毕后这个对象就真正的创建好了。

## 类加载流程

> 当多个线程访问方法区的同一个类时，若这个类未被JVM加载，此时仅允许一个线程执行加载，其余线程必须等待。

JVM加载一个类时必定会经过**加载、连接、初始化** 这三个过程。

其中连接又包括**验证、准备、解析**三个阶段。

![image-20230606160421193](./%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.assets/image-20230606160421193.png)



### 1. 加载

> 类加载器：其实就是一个专门用于加载类的对象 - ClassLoader。它的主要作用就是加载 class字节码 到 JVM 中，当然它还支持加载资源（图片、文本等）。

在类加载的时候，系统会首先判断当前类是否被加载过，已加载过则会之间返回，没有则去尝试加载。

* JVM会使用类加载器 **根据全限定名查询对应的class文件**。
* 读取 class文件的二进制字节流，转换到方法区中。即**将class文件常量池中的内容存放到方法区的运行时常量池中**。
  * 由于加载的是二进制字节流，所以class字节码的来源既可以是本地也可以是远程的。只要符合JVM规范即可。

* 在堆中生成一个代表这个类的 **class类对象，用于访问之前存放在方法区中的数据**。

### 2. 连接

#### 2.1 验证

这个过程主要是为了**确保被加载的类的正确性**。加载的class文件是否符合JVM的规范。

> **验证过程是可以跳过的**，可以使用`-Xverify:none`来关闭验证从而缩短类加载时间。

* **验证文件格式**：校验是否符合class文件格式规范，包含校验是否以`0xCAFEBABE`开头（class文件固定格式头）、主次版本是否支持、常量池中常量类型是否支持等。
* **验证元数据**：对字节码描述的信息进行语义分析，是否符合Java语言规范。
* **验证字节码**：校验类的方法体，分析数据流和控制流，确保在运行时的符合逻辑。
* **验证符号引用**：确保解析动作能正确执行。例如类的全限定名能找到类等。

在解析阶段，JVM将符号引用替换为直接引用（对象的索引值）。

#### 2.2 准备

在准备阶段**会给类的静态变量分配内存**，并且设置对应数据类型的初始值。静态变量最终会随着class对象一起报错到 java堆中。

对于静态常量是直接赋值的指定值。

#### 2.3 解析

**指将常量池中的符号引用替换为直接引用的过程**。主要包括类/接口、字段、方法、方法类型、方法句柄以及调用调用限定符这些符号引用。最终得到这些符号引用在内存中的指针或者偏移量。

### 3. 初始化

> `<clinit> ()`方法是在编译后自动生成的。它是带锁线程安全，因此多线程进行类初始化存在并发阻塞的问题。

初始化阶段会调用 `<clinit>`方法，开始真正执行字节码。

### 类加载时机

* 虚拟机启动时标明的启动类。
* new 对象实例。
* 调用类的静态字段或者方法时。静态常量除外，因为会在编译期间被内联到调用处，所以不会触发类加载。
* 初始化子类时需要先初始化父类。
* JDK8 的 default 接口（默认实现），接口实现类初始化时 会先将接口初始化。

### 类卸载

> 一个类被卸载 就是 这个类对应的 Class 对象被 GC。

使用自定义类加载器加载的类才可能被卸载，被 jvm 自带的类加载器加载的类是不会被卸载的（JDK的 BootstrapClassLoader、ExtClassLoader、AppClassLoader）。

* 类的所有实例都被GC。
* 这个类没有被任何地方引用。
* 类加载器的实例也被GC。

## 内存分配方式

### 指针碰撞

指针碰撞是用于堆中不存在内存碎片的情况下，即内存很整齐。对应使用 **标记-整理** 算法的 GC，例如Serial, ParNew。

在已使用过的内存和没使用过的内存中间存在一个分界指针，分配内存只需要就是将**分界指针向未使用内存方向移动指定内存大小的位置**即可。

### 空闲列表

空闲列表就是用于存在内存碎片的场景。对应使用 **标记-清除** 算法的GC，例如 CMS。

虚拟机维护了一张记录表，里面记录了可用的内存块，分配内存就是在记录表中**查找一块符合大小的内存块分配给对象**，然后更新一下记录即可。

### 如何保证内存分配过程是线程安全的？

* **CAS + 自旋锁**：通过CAS 保证操作的原子性，若更新失败则会通过自旋锁的方式进行失败重试，直到成功。

* **TLAB**：预先为每一个线程在 Eden 区分配一块内存，这样就能先各用各的，当TLAB的内存不够分配时，再使用 CAS的方式分配。





---





## `<clinit>` 和 `<init>`

clinit：类型初始化函数，在JVM执行类型加载时调用，且只执行一次，主要是对static变量进行初始化操作。static 域和 static 代码块都在 clinit 中。

init：java对象创建时执行的实例化操作。

* 子类 init 会先调用 super.init，然后按照顺序进行字段赋值，最后调用 自身的构造函数。

## new语句创建

* 请求内存的 `new` 指令。

* 调用构造器的 `invokespecial` 指令。

构造器调用流程：

> 子类中会优先调用父类的构造器，层层递进直至Object类。

子类构造器调用父类构造器。若父类存在无参构造器，则java编译器会自动添加对父类构造器的调用（隐式调用）。若不存在无参构造器，则需要在子类构造器中显示调用有参构造器（super、this）。