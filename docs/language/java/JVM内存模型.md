# JVM内存模型

![JVM内存模型](./JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png)



## 一、运行时数据区域

### ① 程序计数器

> Program Counter Register 原来你也叫PCR啊🤣。
>
> **线程私有**、**生命周期和线程绑定**。
>
> Java虚拟机规范中**唯一没有规定OOM的区域**。
>

* 是一块较小的内存空间。线程结束后，程序计数器也就不再存在，`生命周期和线程绑定`。
* 字节码解释器工作时通过 修改计数器的值 来选择下一条需要执行的字节码指令（分支、循环、跳转、异常处理、线程恢复等）。
* **记录了线程执行位置**，且**每条线程都有一个独立的程序计数器**, 各线程之间计数器互不影响。从而保证在发生线程切换时`每个线程能够恢复到正确的执行位置`。
- 若线程正在执行**Java方法**：计数器值为**当前正在执行的字节码指令地址**。


    - 若线程正在执行**Native方法**：计数器值为**空（Undefinded）**。


### ② 虚拟机栈

> **线程私有**、**生命周期和线程绑定**。
>
> 当创建一个线程时，会在虚拟机栈中申请一个线程栈。用来保存方法的局部变量、操作数栈、动态链接方法和返回地址等信息，并参与方法的调用和返回。

* 描述的是**Java方法执行的线程内存模型, 为执行Java方法服务**。

* Java虚拟机不是真实的物理机，它没有寄存器，所以**指令集是使用Java栈来存储中间数据**。

* java内存区域当中常说的堆栈中的`栈`通常就是指`虚拟机栈`，更多情况只是指`虚拟机栈中的局部变量表`。

* 栈解决的是程序运行问题，考虑如何执行、如何处理数据。

**可能发生的异常：**

* ``StackOverflowError``：线程请求的栈深度大于虚拟机所允许的升深度时抛出。

* ``OutOfMemoryError``

  - Java虚拟机栈容量可动态拓展(Classic)：**无法申请足够内存时抛出**。

  - Java虚拟机栈容量不可动态拓展(HotSpot)：**线程申请栈空间失败时抛出**。


#### 2.1 栈帧

> 每一个**方法被调用直至结束的过程**，就对应一个栈帧在虚拟机栈中`从入栈到出栈的过程`。
>
> 方法 开始执行 = 栈帧入栈
>
> 方法 执行完毕 = 栈帧出栈	

每个方法被执行的时候，Java虚拟机栈都会同步创建一个**栈帧**(`用于存储方法运行时需要的数据`)。

栈帧中信息主要有:

##### 2.1.1 局部变量表 （Local Variables）

**所需的内存空间在编译期间完成分配**（max_locals）。进入一个方法时，这个方法需要在栈帧中`分配多大的局部变量空间时完全确定的`，且`在方法运行期间不会改变局部变量表的大小`(变量槽Slot的数量)。

一个局部变量槽Slot占32还是64bit是由虚拟机决定的。

一个线程可以将一个基本类型变量的副本传递给另一个线程，但不能共享原始局部变量本身。

| 类型              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| 基本数据类型      | 编译期可知的各种Java虚拟机基本数据类型boolean、byte、 char、 short、 int、 float、 long、 double。 |
| 对象引用          | reference类型不等同于对象本身，可能是指向对象起始地址的引用指针，也可能是代表对象的句柄或其他于此对象相关的位置。 |
| returnAddress类型 | 指向了一条字节码指令的地址。                                 |

> **✨注意点**
>
> 对象`引用存放在栈中的局部变量表中`，具体`对象是存储在堆上`的。
>
> 基础类型并不都是存放在栈中，**方法外定义的全局变量或是成员变量，存放在堆中**。
>
> 包装类是对象所以引用和值是分开存的, 如上一条。即`包装类引用存放在局部变量中，值存储在堆上。`

##### 2.1.2 动态链接

在`.java`文件被编译成`.class`文件时，所有的`变量和方法引用`都作为`符号引用`保存在 Class 文件的常量池里。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。**动态链接的作用就是为了将符号引用转换为调用方法的直接引用**。

##### 2.1.3 方法出口

##### 2.1.4 操作数栈

大小也是在编译器确定（max_stacks）。

用于存放方法执行过程中产生的中间计算结果。指令从操作数栈中`取走数据`并将操作后的`结果重新入栈`。

### ③ 本地方法栈

> **线程私有**

本地方法栈类似于虚拟机栈，区别是Java虚拟机栈服务于java方法，`本地方法栈服务于Native方法`。

**可能发生的异常：**

* `StackOverflowError`：栈深度溢出时抛出。

- `OutOfMemoryError`：栈扩展失败时抛出。

### ④ 堆（heap）

> **所有线程共享**。
>
> Java堆是``垃圾收集器(Garbage Collected)``所管理的内存区域，'几乎'所有的对象对象实例都在这里分配内存。使用逃逸分析技术出现了**栈上分配、标量替换**等优化手段。
>

* 虚拟机启动时创建，且是虚拟机所管理的最大一块内存，**唯一的目的就是存放对象实例**。

* **堆中存储的是`对象实例`或`数组`**。在应用中创建的对象无论是分配给局部变量，或者是作为另一个对象的成员变量，凡是应用中创建的对象都在堆中分配内存。

* 堆处理的是数据的存储。

现代垃圾收集器大部分都是基于分代收集理论设计的。

- 新生代（Young Generation）: 一个Eden和两个Survivor（From Survivor 和 To Survivor）。
- 老年代（Old Generation）:
- ~~永久代（Permanent Generation）~~: HotSpot早期方法区，其他虚拟机并不存在, JDK 6准备计划放弃，JDK 7开始实行，JDK 8 时被元空间替代。
- 元空间（JDK 8后，代替了原先的永久代）

>  逃逸分析（分析对象的作用域）
>
> * 对象只在方法内部使用，则没有发生逃逸。
>
> * 若对象可能被外部引用（传参、返回值），则发生逃逸。
>
> 栈上分配：不会发生逃逸的对象，可能是栈分配，而不是堆分配，随着栈空间一同回收内存。
>
> 标量替换：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分或全部可以存放在CPU寄存器中。

---

### ⑤ 方法区（Method Area）

> **线程共享**
>
>  JVM 运行时数据区域的一块**逻辑区域**，《Java虚拟机规范》中只规定了它的概念和作用，所有在不同的JVM上方法区是有区别的。
>
> 这里以``HotSpot``为例介绍。
>
> 虚拟机规范中，是把方法区描述为堆的一个逻辑部分。
>
> ⚠️`字符串常量池`、`静态变量`从JDK7开始移动到了`堆`中。

* 主要用于存放已被虚拟机加载的类相关信息，包括`类信息`、`常量`、`静态变量`、`即时编译器编译后的代码`等数据，`静态变量`从JDK7开始移动到了`堆`中。

* 方法区在无法满足新的内存分配是，将抛出``OutOfMemoryError``异常

#### 5.1. JDK版本差异(HotSpot)

早期HotSpot使用永久代的方式实现了方法区, 其他虚拟机并不存在永久代这一个概念。元空间和永久代相当于是方法区的不同实现。

##### JDK6及之前版本

此时HotSpot中 方法区=永久代。存储被虚拟机加载的``类型信息``、``常量``、~~``静态变量``~~、``即时编译器编译后的代码缓存``等数据。

##### JDK7版本

> 主要是整理规划存储内容。

从JDK 7开始弱化永久代，将后续准备不再存放在方法区中的``字符串常量池``和``静态变量``移动到了``Java堆``中。其他的依然还在永久代中。

##### JDK8及以后版本

> 只是改变了实现方式，存储的内容并没有变, 同JDK7。

JDK 8 时完全废弃了永久代，改用在本地内存中实现的``元空间(Meta-Space)`` 来替代。

废弃原因：

* 为了融合 HotSpot JVM 与 JRockit VM，而JRockit 没有永久代。

* 内存经常不足甚至发生内存溢出（java.lang.OutOfMemoryError: PermGen）
* 回收效率低。
* 空间大小难以确定

#### 5.2. 运行时常量池

运行时常量池类似于传统编程语言中的符号表。

**Class文件的常量池表**存放了编译期生成的各种`字面量`和`符号引用`，这部分内容将在 **类加载后存放到方法区的`运行时常量池`中**。

运行时常量池具备动态性：除了编译期产生外，运行期间也能将新的常量放入池中。

>  Class文件包含类的版本、字段、方法、接口等描述信息以及常量池表。[Class文件格式、符号引用后续单独补充]()

---

#### 5.3 关于常量池的注意点

> 需要理解和区分`Class文件常量池`、`运行时常量池`和`字符串常量池`直接的区别。

- **Class文件的常量池表**： 存放编译期生成的各种字面量和符号引用。
- **运行时常量池**
  - 类加载后`Class文件的常量池表中的内容`将被存放到运行时常量池中。
  - 具备动态性运行期间也能将新的常量放入池中。
- **字符串常量池**：是JVM针对字符串优化专门开辟的一块区域，避免字符串重复创建。池中存放的是`字符串对象的引用`，具体对象依然是在堆上。

## 二、直接内存

直接内容并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。所以直接内存的分配**不受Java堆大小限制**，**只受设备总内存大小以及处理器寻址空间的限制**。各个内存区域和大于物理内存限制时，从而将导致动态扩展时出现OOM。

> JDK1.4时引入的NIO, 可以使用Native函数库直接分配堆外内存，避免了在Java堆和Native堆中来回复制数据。



### 部分总结

* 栈解决的是程序运行问题，考虑如何执行、如何处理数据。堆处理的是数据的存储。
* 对象`引用存放在栈中的局部变量表中`，具体`对象是存储在堆上`的。
* 基础类型并不都是存放在栈中。基础类型作为局部变量存储在虚拟机栈的局部变量表中，**但作为方法外定义的全局变量或是成员变量时，存放在堆中**。
* 包装类是对象所以引用和值是分开存的, 如上一条。即`包装类引用存放在局部变量中，值存储在堆上。`
* 静态变量从JDK7开始存储到堆中，JDK7之前存储在方法区。
* static声明都是属于类。

# 参考资料

> **深入理解Java虚拟机（第3版）**📚
