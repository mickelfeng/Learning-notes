# JVM学习笔记

## 什么是JVM?

首先是字面意思: Java虚拟机(Java Virtual Machine)。

JVM屏蔽了与具体平台相关的信息，通过在真实的计算机上仿真模拟各种计算机的功能。

**JVM本质上还是一个程序**，它制定了一种用于计算设备的规范。任何平台只需要装上该平台对应的Java虚拟机，就能使得已编译好的字节码文件(.class)在该平台上不加修改的运行。也就是``Compile Once,Run AnyWhere``。

> JVM主要模块划分：类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块

| JVM                   | 备注                                                         |
| --------------------- | ------------------------------------------------------------ |
| Sun Classic VM        | **世界第一款商用Java虚拟机。**<br />纯解释器方式执行。<br />可以外挂即时编译器,不过此时解释器便不再工作。<br />JDK1.0时搭载, 从JDK 1.2开始和HotSpot 共存, 直至1.4完全退出商用虚拟机的历史舞台。<br />基于Handle的对象查找方式。 |
| Exact VM              | JDK1.2版本时在Solaris平台上发表过, 后未普及就被HotSpot Vm替代。<br />采用准确式内存管理,可以知道内存中某个位置的数据具体时什么类型。<br />热点探测、编译器和解释器混合工作等。 |
| **HotSpot VM**        | Sun公司收购后，从JDK1.2开始搭载。<br />**全世界使用最广泛的虚拟机**<br />准确式内存管理、热点代码探测技术、编译器和解释协同工作等。 |
| BEA JRockit           | 后被Oracle收购，不再发展, HotSport从中吸取了部分功能，如Java Mission Control监控工具。 |
| IBM J9                |                                                              |
| Mobile/Embedded VM    |                                                              |
| BEA Liquid VM/Azul VM | 专有虚拟机:与特定硬件平台绑定、软硬件配合。                  |
| Apache Harmony        | 非华为的Harmony OS。😂<br />它的许多代码被吸纳进Google Android SDK中。 |
| Dalvik虚拟机          | **并不是一个Java虚拟机，但和Java存在千丝万缕的关系。**<br />它没有遵循《Java虚拟机规范》，不能直接执行Java的Class文件，使用寄存器架构而不是Java虚拟机中常见的栈架构。<br />Android 5.0 开始使用ART(支持AOT提前编译)全面替代了Dalvik虚拟机。 |
| 一些非主流Java虚拟机  | KVM、Java Card VM、Squawk VM等等。                           |

## JVM常用参数

| 参数                    | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| Xms（初始内存大小）     | 程序启动时的内存大小。一般情况下，越大程序启动越快，但是可能导致机器变慢。 |
| Xmx（扩容内存大小）     | 程序运行期间最大可占用的内存大小，超出限制时将会跑出OOM异常。 |
| Xss（线程栈大小）       | 每个线程堆栈的大小。                                         |
| -XX:TraceClassLoading   | 跟踪类加载情况                                               |
| -XX:TraceClassUnloading | 跟踪类卸载情况                                               |
| -Xint                   | 指定只进行解释执行，相当于抛弃了JIT。                        |
| -Xcomp                  | 关闭解释执行                                                 |



## JVM性能相关概念

> 在使用GC算法时，需要明确目标：``最大吞吐量``还是``最小暂停时间``。在两者之间折衷选择。

### 1. 吞吐量

吞吐量 = ``用户代码执行时间/（用户代码执行时间 + 垃圾回收时间）``，吞吐量越高越好。

```
用户代码运行时间：100min
垃圾回收时间：1min
吞吐量 = 99/(99 + 1) = 99%
```

设置吞吐量的大小： ``-XX:GCRatio``

**吞吐量最优的垃圾回收器**(``PS/PO``)

```
-XX:+UseParallelGC
-XX:+UseParallelOldGC
```

### 2. 延迟

低延迟(STW): 越短响应时间越好。

**响应时间最优的垃圾回收器**：``CMS``、``G1``

### 3. GC类型

- FullGC：

  ```
  FullGC比较耗时，会会使应用程序延迟增加或者吞吐量降低。
  ```

- MinorGC：尽可能多的收集垃圾对象，可以降低FullGC的发生频率

## JVM相关工具

### 1. 调优工具

- MAT

  ```
  Eclipse
  提示可能存在内存泄漏的点
  ```

- jvisualvm

  ```
  Java自带
  ```

- jconsole

  ```
  Java自带
  ```

- Arthas

  ```
  阿里
  ```

- show-busy-java-threads

  ```
  github开源
  ```

## JVM编译方式

### 即时编译（JIT compiler）

> 运行时即时编译：just-in-time compilation。
>
> 开发期时的热重载是基于JIT。

能够动态下发和执行代码，在**运行时将热点代码编译成机器码**。为了避免JIT预热等各方面的开销，JDK9引入了AOT。同时为了支持动态特性也保留了JIT。

- C1

  对应客户端，适用于对启动速度敏感的应用。

- C2

  对应用服务端。

### 运行前编译（AOT compiler）

> 运行前编译：Ahead of Time Compilation。

AOT的典型代表时C/C++，直接将class字节码编译成机器码，执行性能表现好，缺点就是每次执行都要提前编译，影响开发测试效率。

发布期则一般使用AOT。

### 字节码

即`.class`文件，它是可以被JVM理解处理的代码。它不面向任何特定的处理器，仅面向虚拟机。它被类加载器加载，解释或编译执行。

* 字节码保留了解释型语言可移植的特性。
* 优化了解释型语言执行效率低的问题（相对C++、Go等还有一定差距）。

### 即时编译器的重排序

以下列代码为例：

```java
int a = 1; // 1
int b = 2; // 2
int c = a + b; // 3
```

在Java中正常的执行顺序是 `1 > 2 > 3`。

不过Java运行编译器允许重排序，由于语句1 和 语句2 不存在关联，重排序后可以变为 `2 > 1 > 3`，但是3永远不在1、2之前。

> 在线程中无论怎么重排序，程序的执行结果都不会改变。

 但是在多线程中重排序就可能会导致一些问题。

* 开启 线程1执行 `onThread1()`。 开启线程2 执行 `onThread2()`。
* 假设发生重排：`canDo = true` 先执行。
* 假设发生并发：接着执行了 `onThread2()`。此时 `a = 2`。
* 最后执行 `a = 1`；
* 结果  `a = 1`。

```java
int a = 0;
boolean canDo = false;

public void onThread1() {
    a = 1 //
    canDo = true; // 重排后，canDo可能先执行
} 

public void onThread2() {
    if(canDo) { // 由于并发
        a = 2; // 
    }
}
```

> 在double check 中重排导致的问题，第 3步赋值操作 可能发生在 2之前。
>
> 1. 分配内存空间。
> 2. 初始化Singleton实例。
> 3. 赋值给 instance 实例引用。

## JVM运行原理

### 执行流程

当我们运行Java代码时，JVM会通过类加载器(Class-Loader)加载字节码，解释或者编译执行。主要流程如下：

1. **JVM 向操作系统申请内存**。操作系统通过JVM配置参数的内存大小找到具体的内存分配表，然后将内存段的起始地址和终止地址分配给JVM。之后交由JVM内部进行分配。
2. **分配堆、栈以及方法区的内存大小**。JVM获得内存空间后，根据配置参数进行分配。
3. **class文件的加载、链接（验证、准备以及解析）**。在准备阶段会为静态变量分配内存，初始化系统的初始值（并不是指我们代码指定的初始值）。
4. **初始化：执行构造器`<clinit>`**。之前编译器在将`.java`编译成`.class`时，会收集所有类的初始化代码（静态变量赋值语句、静态代码块、静态方法），生成`<clinit>`方法
5. **执行main方法**。执行main线程的main方法，启动程序。



## JVM类加载流程

> 当多个线程访问方法区的同一个类时，若这个类未被JVM加载，此时仅允许一个线程执行加载，其余线程必须等待。

JVM加载一个类时必定会经过**加载、连接、初始化** 这三个过程。

其中连接又包括**验证、准备、解析**三个阶段。

![image-20230606160421193](./JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20230606160421193.png)



### 加载

> 类加载器：其实就是一个专门用于加载类的对象 - ClassLoader。它的主要作用就是加载 class字节码 到 JVM 中，当然它还支持加载资源（图片、文本等）。
>
> 在类加载的时候，系统会首先判断当前类是否被加载过，已加载过则会之间返回，没有则去尝试加载。
>
> 由于加载的是二进制字节流，所以class字节码的来源既可以是本地也可以是远程的。

* 首先 JVM会使用类加载器 根据全限定名获取class文件的二进制字节流。

* JVM会将class文件常量池中的内容存放到 方法区的运行时常量池中。
* 同时在推中会生成一个代表这个类的 class对象，用于访问之前存放在方法区中的数据。

### 连接

#### 验证

这个过程主要是为了**确保被加载的类的正确性**。即确保加载的class文件是否符合JVM的规范。

> 验证过程是可以跳过的，可以使用`-Xverifynone`来关闭验证从而缩短类加载时间。

* 验证文件格式：包含校验是否是class文件（以`0xCAFEBABE`开头）、版本是否支持等。
* 验证元数据：对字节码描述的信息进行语义分析，是否符合Java语言规范。
* 验证字节码：分析数据流和控制流，确保程序语义的合法。
* 验证符合引用：确保解析动作能正确执行。

在解析阶段，JVM将符号引用替换为直接引用（对象的索引值）。



### 初始化









# 参考资料

> **深入理解Java虚拟机（第3版）**📚