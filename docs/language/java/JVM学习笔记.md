# JVM学习笔记

## 什么是JVM?

首先是字面意思: Java虚拟机(Java Virtual Machine)。

JVM屏蔽了与具体平台相关的信息，通过在真实的计算机上仿真模拟各种计算机的功能。

**JVM本质上还是一个程序**，它制定了一种用于计算设备的规范。任何平台只需要装上该平台对应的Java虚拟机，就能使得已编译好的字节码文件(.class)在该平台上不加修改的运行。也就是``Compile Once,Run AnyWhere``。

> JVM主要模块划分：类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块



| JVM                   | 备注                                                         |
| --------------------- | ------------------------------------------------------------ |
| Sun Classic VM        | **世界第一款商用Java虚拟机。**<br />纯解释器方式执行。<br />可以外挂即时编译器,不过此时解释器便不再工作。<br />JDK1.0时搭载, 从JDK 1.2开始和HotSpot 共存, 直至1.4完全退出商用虚拟机的历史舞台。<br />基于Handle的对象查找方式。 |
| Exact VM              | JDK1.2版本时在Solaris平台上发表过, 后未普及就被HotSpot Vm替代。<br />采用准确式内存管理,可以知道内存中某个位置的数据具体时什么类型。<br />热点探测、编译器和解释器混合工作等。 |
| **HotSpot VM**        | Sun公司收购后，从JDK1.2开始搭载。<br />**全世界使用最广泛的虚拟机**<br />准确式内存管理、热点代码探测技术、编译器和解释协同工作等。 |
| BEA JRockit           | 后被Oracle收购，不再发展, HotSport从中吸取了部分功能，如Java Mission Control监控工具。 |
| IBM J9                |                                                              |
| Mobile/Embedded VM    |                                                              |
| BEA Liquid VM/Azul VM | 专有虚拟机:与特定硬件平台绑定、软硬件配合。                  |
| Apache Harmony        | 非华为的Harmony OS。😂<br />它的许多代码被吸纳进Google Android SDK中。 |
| Dalvik虚拟机          | **并不是一个Java虚拟机，但和Java存在千丝万缕的关系。**<br />它没有遵循《Java虚拟机规范》，不能直接执行Java的Class文件，使用寄存器架构而不是Java虚拟机中常见的栈架构。<br />Android 5.0 开始使用ART(支持AOT提前编译)全面替代了Dalvik虚拟机。 |
| 一些非主流Java虚拟机  | KVM、Java Card VM、Squawk VM等等。                           |

## JVM常用参数

| 参数                    | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| Xms（初始内存大小）     | 程序启动时的内存大小。一般情况下，越大程序启动越快，但是可能导致机器变慢。 |
| Xmx（扩容内存大小）     | 程序运行期间最大可占用的内存大小，超出限制时将会跑出OOM异常。 |
| Xss（线程栈大小）       | 每个线程堆栈的大小。                                         |
| -XX:TraceClassLoading   | 跟踪类加载情况                                               |
| -XX:TraceClassUnloading | 跟踪类卸载情况                                               |
| -Xint                   | 指定只进行解释执行，相当于抛弃了JIT。                        |
| -Xcomp                  | 关闭解释执行                                                 |



## JVM性能相关概念

> 在使用GC算法时，需要明确目标：``最大吞吐量``还是``最小暂停时间``。在两者之间折衷选择。

### 1. 吞吐量

吞吐量 = ``用户代码执行时间/（用户代码执行时间 + 垃圾回收时间）``，吞吐量越高越好。

```
用户代码运行时间：100min
垃圾回收时间：1min
吞吐量 = 99/(99 + 1) = 99%
```

设置吞吐量的大小： ``-XX:GCRatio``

**吞吐量最优的垃圾回收器**(``PS/PO``)

```
-XX:+UseParallelGC
-XX:+UseParallelOldGC
```

### 2. 延迟

低延迟(STW): 越短响应时间越好。

**响应时间最优的垃圾回收器**：``CMS``、``G1``

### 3. GC类型

- FullGC：

  ```
  FullGC比较耗时，会会使应用程序延迟增加或者吞吐量降低。
  ```

- MinorGC：尽可能多的收集垃圾对象，可以降低FullGC的发生频率

## JVM相关工具

### 1. 调优工具

- MAT

  ```
  Eclipse
  提示可能存在内存泄漏的点
  ```

- jvisualvm

  ```
  Java自带
  ```

- jconsole

  ```
  Java自带
  ```

- Arthas

  ```
  阿里
  ```

- show-busy-java-threads

  ```
  github开源
  ```



## JVM执行过程

JVM通过类加载器(Class-Loader)加载字节码，解释或者编译执行。

> 开发期时的热重载是基于JIT。
>
> 而发布期则一般使用AOT。

### 字节码

即`.class`文件,是可以被JVM理解处理的代码。它不面向任何特定的处理器，仅面向虚拟机。它被类加载器加载，解释或编译执行。

* 字节码保留了解释型语言可移植的特性。
* 优化了解释型语言执行效率低的问题（相对C++、Go等还有一定差距）。

### 即时编译（JIT compiler）

> 运行时即时编译：just-in-time compilation。

能够动态下发和执行代码，在**运行时将热点代码编译成机器码**。为了避免JIT预热等各方面的开销，JDK9引入了AOT。同时为了支持动态特性也保留了JIT。

- C1

  对应客户端，适用于对启动速度敏感的应用。

- C2

  对应用服务端。

### 运行前编译（AOT compiler）

> 运行前编译：Ahead of Time Compilation。

AOT的典型代表时C/C++，直接将class字节码编译成机器码，执行性能表现好，缺点就是每次执行都要提前编译，影响开发测试效率。





## 即时编译器的重排序

# 参考资料

> **深入理解Java虚拟机（第3版）**📚