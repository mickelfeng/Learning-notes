# JVM垃圾收集器

> 垃圾收集器需要考虑的核心问题：
>
> 1. 哪些内存需要回收？
>
> 2. 什么时候回收？
>
> 3. 如何回收？

垃圾收集器主要管理的就是 **Java堆**，也包括了方法区中的部分对象回收，主要是常量池的回收和类的卸载。

## 垃圾回收算法

### 标记清除

标记存活对象（不需要的回收的对象），然后将未标记的对象都清除。

* 容易产生大量不连续的内存，使得大内存对象无法被分配，最终造成内存浪费。

### 标记整理

不同于标记清除的点在于多了一步整理，主要是解决了碎片化内存的问题。

标记存活对象，然后将存活对象向同一端移动，然后清理存活端边界外的对象。

* 效率并不高，不适用于频繁回收的场景。

### 复制

将内存一分为二，每次只使用其中的一块内存，当这块内存不够分配时，就将存活的对象复制到另一块内存中，然后将之前使用的那块内存直接清理。在复制的过程中也解决了内存碎片化的问题。

* 仅使用一半内存，导致内存利用率不高。
* 存活大量对象时，复制操作会很耗费性能。适用于频繁回收、存活对象不多的场景。

### 分代收集

根据对象的存活周期来进行内存划分，再更加不同年代的特点从上述的3个算法中选择合适的。

- 新生代: 复制算法。
- 老年代: 标记清除 或者 标记整理。



## 分代收集理论

现代垃圾收集器大部分都是基于**分代收集理论**设计的。以经典分代为例：

- 新生代（Young Generation）: 包括一个Eden和两个Survivor（From Survivor 和 To Survivor）。
- 老年代（Old Generation）:
- ~~永久代（Permanent Generation）~~: HotSpot早期方法区，其他虚拟机并不存在, JDK 6准备计划放弃，JDK 7开始实行，JDK 8 时被**元空间（MetaSpace）**替代。



| GC                  |                    |                                                              |
| ------------------- | ------------------ | ------------------------------------------------------------ |
| Minor GC / Young GC | 仅对新生代进行GC   | 在进行Minor GC 之前一般会先检查老年代是否存在足够的连续空间存放 新生代的所有对象，不够时 会转为 Full GC。 |
| Minor GC / Young GC | 仅对老年代进行GC   |                                                              |
| Full GC             | 针对整个 堆 进行GC |                                                              |

### GC 回收原则

* 一般情况下，对像会优先在新生代的Eden区分配。即刚**刚创建的对象一般在 Eden中**。
* 若Eden区没有足够空间继续进行分配，此时虚拟机会先发起一次 `Minor GC`，尝试回收对象。
* 对于经过Minor GC后依然存活对象，若
* 对于经过Minor GC后依然存活对象，会先尝试放到到 Survivor区 中，同时并且对象的年龄计数 + 1。
  * 每次Minor GC 后 Survivor 中存活的对象 年龄计数都会 + 1。
* Survivor 中中长期存活的对象，会被存放到老年代中。即对象达到一定年龄（不同虚拟机数值不同）

GC回收时，将Eden区中存活的对象放入Survivor From中，下一次回收时将Survivor From中的对象存入Survivor To中

## 对象存活条件

### 引用计数法

通过给对象添加一个计数器，每有一个地方引用就 加1，引用失效（引用方被回收）时就减1。计数归0就这个对象不存在引用，可以被回收。例如 智能指针`sp(StrongPointer)` 就是引用计数。

不过这种方法存在一个问题，那就是对象间的循环引用问题，两个对象互相引用对方，导致两者都无法被回收。因此主流的虚拟机并没有采用这个算法。

### 可达性分析

定义了一系列 `GC Roots` 对象来作为起点，并将所有有关联的对象进行连接，形成引用链。可达性分析就是分析的对象能否和 GC Roots 之间形成引用链。

* 若一个对象和 GC Roots 之间存在引用链，就表示对象是当前需要的，就不会被回收。否则表示当前没有被使用，可以被回收。

关键就是 `GC Roots` 怎么定义：

* **虚拟机栈中引用的对象**。栈中的栈帧表示的是当前正在执行的方法，里面的引用就是当前方法执行需要使用的对象。
* **本地方法栈中引用的对象**。和虚拟机栈一样，只不过本地方法栈表示的 Native 函数。
* **方法区中类静态属性引用的对象**：指静态变量引用的对象。
* **方法区中的常量引用的对象**：指存在于常量池中的对象。



## 观察GC日志

```shell
# Concurrent----后台回收内存，不暂停用户线程
# Alloc----当app要申请内存，而堆又快满了的时候，会阻塞用户线程

Explicit----调用Systemt.gc()等方法的时候触发，一般不建议使用

NativeAlloc----当native内存有压力的时候触发

Name
Concurrent mark sweep----全部对象的检测回收
Concurrent partial mark sweep----部分的检测回收
Concurrent sticky mark sweep----仅检测上次回收后创建的对象，速度快，卡顿少，比较频繁

```



### 输出GC信息

> 允许时添加 VM options： -XX:+PrintGCDetails

![image-20230711173206777](./JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(GC).assets/image-20230711173206777.png)

运行程序后会输出GC信息。

![image-20230711173241318](./JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8(GC).assets/image-20230711173241318.png)
