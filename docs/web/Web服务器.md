# Web服务器



## Apache



## Nginx

Nginx是要给 轻量级的Web服务器，CPU、内存占用都非常少。

Nginx 采用 **进程池 + 单线程**	的工作模式。消除了进程/线程创建和切换的成本。

* 预先创建固定数量的**worker进程**组成**进程池**，之后就不在fork新进程了。
* 自动把**进程绑定到独立的CPU**上，发挥多核性能。
* 为了摆脱外部依赖，Nginx自行实现了master进程。并由**master进程来管理进程池**。负责监控并恢复异常的Worker进程，保证服务的稳定性。

### I/O多路复用

> 多路复用是指 多个I/O请求 复用 到一个进程或线程里处理。
>
> 即当一个连接发生阻塞就立刻切换，去处理其他的请求。从而消除了I/O阻塞，从而充分利用CPU。

Web服务器主要是 **I/O密集型**关键在于网络收发而不是CPU计算。网络IO网络会出现大量的等待（等待对端响应、等待数据到达等）导致CPU空闲。

所以Nginx利用 **I/O多路复用接口（ `epoll`） ,** 即使是单线程在处理能力上也超越了其他很多多线程的服务器。

#### BIO（Block IO）

同步阻塞IO，默认的Socket编程就是阻塞IO。每个客户端连接都需要一个线程来接收数据，十分浪费。

* 创建 Socket 接口。
* 通过 `bind()`  将接口号和端口号进行绑定。
* 开启一个循环，在循环中调用 `read` 读取或 `listener`监听事件，但是是阻塞的。
* 有客户端连接 或者消息发送过来时会被唤醒。

#### NIO（NONBLOCK IO）

同步非阻塞IO。和BIO的区别主要是无需阻塞等待。等待事件时线程是挂起的，处理事件还是阻塞的。

* 创建 Socket 接口。
* 通过 `bind` 函数 将接口号和端口号进行绑定。
* 监听事件，同时**将Socket标记为非阻塞**。
* 遍历检查所有socket，有事件就处理。

#### select

进程告诉内核（多路复用器）所有的Socket。然后内核**会遍历所有Socket**，当某个socket有事件发生时，就去该socket上处理事件。

#### epoll

epoll **不需要遍历**所有的socket， 仅**管理活跃的连接**。只当连接真正可读、可写时才会处理，若发生阻塞就立刻切换，处理其他的请求。

epoll大量的连接管理是在操作系统内核里做的，应用程序负担小，可以建立大量的连接而仅消耗不多的内存。（几十万连接 = 几百M内存）

流程：

* 调用 `epoll_create()` 创建一个文件，返回一个fd。
* 创建Socket、绑定端口号、监听事件，同时标记为非阻塞。
* 调用 `epoll_ctl()` 将socket 和 监听事件写入 fd。
* 开启循环 调用 `epoll_wait()`函数进行监听，此函数返回已经就绪事件的长度（0表示没有）。



### 阶段式处理（流水线）

> Nginx使用的是静态配置文件，所以每次修改配置必须要重启。后续引入了 JavaScript，实现了一定程度的动态化。

Nginx 支持通过模块配置的方式进行任意组合，具有很高的扩展性，十分灵活。

Nginx 使用 责任链模式，以流水线的方式各个模块。



### Nginx HTTP配置

HTTP处理主要包括四大类模块：

* **handler**：直接**处理 HTTP 请求**；
* **filter**：不直接处理请求，而是**加工过滤响应报文**；
* **upstream**：实现**反向代理**功能，**转发请求**到其他服务器；
* **balance**：实现**反向代理时的负载均衡算法**。





## OpenResty

OpenResty 基于 Nginx，并利用Lua 进行了增加。

* 动态配置：依靠Lua 的代码热加载，不需要重启就能更新配置。
* 多路复用：Nginx基于系统级别的多路复用 epoll，OpenResty基于Lua的协程的同步非阻塞特性，实现了应用层级别的多路复用，消耗的资源更少。
* 阶段式处理：Nginx的流水线由一个个C模块构成，OpenResty的流水线则是由 一个个 Lua脚本构成。