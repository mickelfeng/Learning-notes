# Java相关面试题

## 基础知识

### 如何处理浮点数精度缺失和超过long的整型数值？

精度缺失产生的原因：

由于计算机是使用的二进制运算，而计算机在表示一个数字是位数是有限的，所以在处理无限循环的小数时只能截断，导致精度丢失。

由于精度缺失问题在《阿里巴巴Java开发手册》中提到：**浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断**。

* 使用`BitInteger`处理超过long的数据，内部是使用`int[]`数组来存储任意大小的整型数据，`BigDecimal.valueOf(double val)`存在精度损失风险。

* 使用`BigDecimal`处理浮点数精度丢失问题，推荐使用`BigDecimal(String val)`。

---

### Java和C++的区别

相同点：

* 都是面向对象语言，支持封装、继承和多态。

不同点：

* Java是单继承不支持多继承，C++支持多继承。
* C++提供了指针操作，可以直接访问内存，Java不能。
* Java有垃圾回收机制，自动管理内存，C++需要自己管理。
* C++支持方法重载和操作符重载，Java只支持方法重载。

---

### 自增自减运算符

> `++`、`--`
>
> 注意运算符的位置而导致的差异

运算符在变量后（先赋值后运算）：

```java
b = 1;
// 先赋值后计算
a = b++;
// a = 1;
// b = 2;
```

运算符在变量前（先运算后赋值）：

```java
b = 1;
// 先自增 在赋值
a = ++b;
// a = 2;
// b = 2;
```

---

### 基础类型和包装类型的区别

* 默认值：包装类型的默认值是null, 基础类型的默认值是具体的某个值。
* 泛型：包装类型可用于泛型，基础类型则不行。
* 内存存储位置：包装类属于对象类型，对象实例存储在堆中。基础类型作为局部变量存储在虚拟机栈的局部变量表中。
* 内存占用：基础类型占用空间更小。
* 比较方式：基础类型直接值比较，包装类型则时`equals`比较，值相同，对象不一定相同。

---

### 接口和抽象类的区别

共同点：

* 两者都不能被实例化。
* 都可以有默认实现。Java 8 之后可以使用`default`定义接口的默认实现。
* 都有抽象方法。

不同点：

* Java中一个类无法多继承，所以只能继承一个抽象类，但是可以实现多个接口。
* 目的不同：抽象类强调的是代码复用，接口强调的是约束规范。
* 成员变量访问权限不同：接口一定是`public static final`的必须初始化赋值不可修改。抽象类则是和普通的类相同，默认为`default`，不一定需要初始化赋值，可修改。



---

### 面向对象和面向的区别

* 面向过程：将问题拆解为一个个方法，然后一步步调用方法解决问题。

* 面向对象：先对问题进行抽象，抽象出一个对象。然后通过操作对象来解决问题。更加清晰，易维护。



---

### JDK & JVM & JRE 的区别和联系

**JVM是Java虚拟机**（例如HotSpot），针对不同的系统有特定的实现，但是上面运行的是相同的字节码，是Java实现跨平台的关键`Compile Once,Run AnyWhere`。

**JRE是Java运行时环境**，包含了JVM和一些标准类库，可以在上面运行Java程序。

**JDK是Java软件开发工具包**，包含了JRE和一些开发工具集（javac等）。涉及到编译都需要安装JDK（如JSP）。

三者是包含关系：JDK > JRE > JVM

* JDK = JRE + 开发工具集

* JRE = JVM + Java标准类库

---

### Java是解释执行吗？

> **Java 是编译与解释共存的语言**。

​	Java会先通过 `javac` 将 `.java 文件`**编译**成`.class文件`。在运行时Java虚拟机内嵌的解释器会逐条读入，逐条**解释运行**，这也是Java实现跨平台的原因。

​	同时Java虚拟机也提供了JIT编译器，能在运行时将**热点代码直接编译成机器码**，此时这些热点代码就属于编译执行。

---



## JVM相关

### 什么是字节码

即`.class`文件,是可以被JVM理解处理的代码。它不面向任何特定的处理器，仅面向虚拟机。它被类加载器加载，解释或编译执行。

* 字节码保留了解释型语言可移植的特性。
* 优化了解释型语言执行效率低的问题（相对C++、Go等还有一定差距）。

### 字符串常量池相关问题

> 字符串常量池 是 JVM 为了提升性能和减少内存消耗针对String专门开辟的一块区域，主要**目的是为了避免字符串的重复创建**。

**String a = new String("aaa");创建了多少个字符串对象？**

答案是：1个或2个字符串对象。

首先由于`new String()`会先在堆上创建一个字符串对象。

若字符串常量池中存在字符串`aaa`的引用，则这个`new String对象`赋值为字符串`aaa`的引用。此时仅创建一个字符串对象。

若字符串常量池中不存在字符串`aaa`的引用，则需要创建一个String对象`aaa`同时将它的引用存放到常量池中。最后再为这个`new String对象`赋值为字符串`aaa`的引用。此时仅创建两个字符串对象。



### JVM性能调优概述

基本原则：

- 虚拟机内部已存在许多的优化保证能够稳定使用，当已经出现或者将会出现时再考虑优化。
- 上线前，考虑将JVM参数设置调整到适合当前需求。
- GC优化是最后手段，应优先考虑优化项目的代码和架构，项目实在没有多少优化空间时再考虑优化GC。
- GC内存最大化原则：处理吞吐量和延迟问题时根据实际调整, 能使用的内存越大(java堆越大)，垃圾收集效果越好。
- GC调优3选2原则：吞吐量、延迟、内存中选择2个进行调优。

调优场景：

- Heap内存（老年代）持续上涨达到设置的最大内存值。

- 发生内存异常

  ```
  OutOfMemory
  OutOfDirectMemoryError
  ```

- 应用使用了本地缓存且占用大量内存空间。

- 应用的CPU或内存占用过高不下。

- 系统的吞吐量和响应性能不高或下降。

- 监控GC情况

  ```
  - FullGC是否过于频繁。最大持续时间。
  - MinorGC持续时间、次数
  - GC停顿（Stop-The-World）太长，例如超过1秒。
  ```

排查流程：

- CPU占用过高场景

  ```shell
  # 1. 查询CPU占用最高的进程的pid，例如：12345
  top
  # 2. 然后查询该进程下占用最高的线程id,例如 6789
  top -H -p 12345
  # 3. 将线程ID转换为16进制(java native线程已16进制输出)
  printf '%x\n' 6789
  # 4. 打印java线程调用栈信息，定位问题
  jstack 12345 | grep '0x1a85' -A 50 --color
  ```

- 内存占用过高场景

  ```shell
  # 1. 查询内存占用最高的进程的pid，例如：12345
  top -d 2 -c
  # 2. 查看JVM堆内存分配情况
  jmap -heap 12345
  # 3. 查看占用内存比较多的对象
  jmap -histo 12345 | head -n 100
  # 4. 查看占用内存比较多的存活对象
  jmap -histo:live 12345 | head -n 100
  ```

  

###  JVM有哪些垃圾回收器

> **新生代收集器**（都是复制算法）：Serial、ParNew、Parallel Scavenge
>
> **老年代收集器**：CMS（标记-清理）、Serial Old（标记-整理）、Parallel Old（标记-整理）
>
> **整堆收集器**：G1（一个Region中是标记-清除算法，2个Region之间是复制算法）

**1. Serial/Serial Old收集器**

> Serial收集器是最基本、发展历史最悠久的收集器。

**特点：**单线程、简单高效(同是单线程时比较)。进行垃圾回收时必须暂停其他所有的工作线程，直至它结束(STW)。

**适用场景**：Client模式下的虚拟机。

**2. ParNew收集器**

> ParNew其实是Serial收集器的多线程版本。

---

## 线程相关

### 线程池

### ThreadLocal有哪些内存泄漏问题

查看Entry类的结构可以知道，它继承自WeakReference。对于Thread对象来说,**key值ThreadLocal实例是弱引用关系，而value实质是一个强引用关系**。 所以当这个线程没有销毁时，就会出现泄漏问题。特别是使用线程池时。

如何处理：可以显示调用``ThreadLocal.remove()``

---

### Daemon线程和User线程

User线程

> `new Thread`默认创建的就是User线程。

```java
Thread threadA = new Thread(new Runnable(){...});
threadA.start();
```

如何创建`Daemon线程`：

```java
Thread threadA = new Thread(new Runnable(){...});
// 设置为Daemon线程，需要在start之前调用。
threadA.setDaemon(true);
threadA.start();

// 可以通过 threadA.isDaemon()判断。
```

User线程和Daemon线程的差异

* JVM进程退出的条件是，不存在User线程。即仅存在 守护线程时虚拟机会直接退出。
* main函数所在线程的退出，不影响其他User线程的运行，也不影响JVM进程是否退出执行。
* 当JVM中所有的User线程退出后，所有的Daemon线程也会马上退出执行，并且JVM进程也会退出。





## 动态代理

> 主要考察反射机制。
>
> 动态代理解决了什么问题。
