# Java相关面试题

## 1. JVM性能调优概述

基本原则：

- 虚拟机内部已存在许多的优化保证能够稳定使用，当已经出现或者将会出现时再考虑优化。
- 上线前，考虑将JVM参数设置调整到适合当前需求。
- GC优化是最后手段，应优先考虑优化项目的代码和架构，项目实在没有多少优化空间时再考虑优化GC。
- GC内存最大化原则：处理吞吐量和延迟问题时根据实际调整, 能使用的内存越大(java堆越大)，垃圾收集效果越好。
- GC调优3选2原则：吞吐量、延迟、内存中选择2个进行调优。

调优场景：

- Heap内存（老年代）持续上涨达到设置的最大内存值。

- 发生内存异常

  ```
  OutOfMemory
  OutOfDirectMemoryError
  ```

- 应用使用了本地缓存且占用大量内存空间。

- 应用的CPU或内存占用过高不下。

- 系统的吞吐量和响应性能不高或下降。

- 监控GC情况

  ```
  - FullGC是否过于频繁。最大持续时间。
  - MinorGC持续时间、次数
  - GC停顿（Stop-The-World）太长，例如超过1秒。
  ```

排查流程：

- CPU占用过高场景

  ```shell
  # 1. 查询CPU占用最高的进程的pid，例如：12345
  top
  # 2. 然后查询该进程下占用最高的线程id,例如 6789
  top -H -p 12345
  # 3. 将线程ID转换为16进制(java native线程已16进制输出)
  printf '%x\n' 6789
  # 4. 打印java线程调用栈信息，定位问题
  jstack 12345 | grep '0x1a85' -A 50 --color
  ```

- 内存占用过高场景

  ```shell
  # 1. 查询内存占用最高的进程的pid，例如：12345
  top -d 2 -c
  # 2. 查看JVM堆内存分配情况
  jmap -heap 12345
  # 3. 查看占用内存比较多的对象
  jmap -histo 12345 | head -n 100
  # 4. 查看占用内存比较多的存活对象
  jmap -histo:live 12345 | head -n 100
  ```

  

## 2. JVM有哪些垃圾回收器

> **新生代收集器**（都是复制算法）：Serial、ParNew、Parallel Scavenge
>
> **老年代收集器**：CMS（标记-清理）、Serial Old（标记-整理）、Parallel Old（标记-整理）
>
> **整堆收集器**：G1（一个Region中是标记-清除算法，2个Region之间是复制算法）

**1. Serial/Serial Old收集器**

> Serial收集器是最基本、发展历史最悠久的收集器。

**特点：**单线程、简单高效(同是单线程时比较)。进行垃圾回收时必须暂停其他所有的工作线程，直至它结束(STW)。

**适用场景**：Client模式下的虚拟机。

**2. ParNew收集器**

> ParNew其实是Serial收集器的多线程版本。

## 3. ThreadLocal有哪些内存泄漏问题

查看Entry类的结构可以知道，它继承自WeakReference。对于Thread对象来说,**key值ThreadLocal实例是弱引用关系，而value实质是一个强引用关系**。 所以当这个线程没有销毁时，就会出现泄漏问题。特别是使用线程池时。

如何处理：可以显示调用``ThreadLocal.remove()``





### 4. Java是解释执行吗？

> Java是解释执行，但是也支持编译执行。

​	Java通过Javac编译成.class类型文件，在运行时Java虚拟机内嵌的解释器，逐条读入，逐条解释运行，此时是解释执行，这也是Java实现跨平台的原因。

​	Java虚拟机都提供了JIT编译器，能在运行时将热点代码直接编译成机器码，此时这些热点代码就属于编译执行。