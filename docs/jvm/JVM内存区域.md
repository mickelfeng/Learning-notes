# JVM内存区域

## 一、运行时数据区域

### ① 程序计数器

> **线程私有**、**生命周期和线程绑定**。
>
> 程序控制流的指示器: 记录当前线程执行的``字节码的行号指示器``。
>
> Java虚拟机规范中唯一没有规定OOM的区域。
>
> Program Counter Register 原来你也叫PCR啊🤣。

**字节码解释器工作时通过修改计数器的值来选择下一条需要执行的字节码指令。**

**每条线程都有一个独立的程序计数器**, 各线程之间计数器互不影响，保证``线程切换时能够恢复到正确的执行位置``。

**程序计数器主要用于记录线程执行位置**，所以线程结束后，程序计数器也就不再存在，``生命周期和线程绑定``。

具体记录的内容:

- 若正在执行Java方法：计数器值为正在执行的**虚拟机字节码指令地址**。

- 若正在执行Native方法：计数器值为空（Undefinded）。

### ② 虚拟机栈

> **线程私有**、**生命周期和线程绑定**。
>
> 虚拟机栈描述的是**Java方法执行的线程内存模型**, ``为执行Java方法服务``。
>

Java虚拟机不是真实的物理机，它没有寄存器，所以指令集是使用Java栈来存储中间数据。

java内存区域当中常说的``堆栈``中的``栈``通常就是指``虚拟机栈``，更多情况只是指虚拟机栈中的局部变量表。

``StackOverflowError``

- 线程请求的栈深度大于虚拟机所允许的升深度时抛出。

``OutOfMemoryError``

- Java虚拟机栈容量可动态拓展(Classic)：无法申请足够内存时抛出。
- Java虚拟机栈容量不可动态拓展(HotSpot)：线程申请栈空间失败时抛出。

#### 2.1 栈帧

> 每一个方法被调用直至结束的过程，就对应一个栈帧在虚拟机栈中``从入栈到出栈的过程``。
>
> 方法开始执行 = 栈帧入栈
>
> 方法执行完毕 = 栈帧出栈	

每个方法被执行的时候，Java虚拟机栈都会同步创建一个栈帧(``用于存储方法运行时需要的数据``)。

栈帧中信息主要有:

##### 2.1.1 局部变量表 （Local Variables）

> **所需的内存空间在编译期间完成分配**。进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间时完全确定的，且**在方法运行期间不会改变局部变量表的大小**(变量槽Slot的数量)。
>
> 一个局部变量槽Slot占32还是64bit是由虚拟机决定的。

| 类型              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| 基本数据类型      | 编译期可知的各种Java虚拟机基本数据类型boolean、byte、 char、 short、 int、 float、 long、 double。 |
| 对象引用          | reference类型不等同于对象本身，可能是指向对象起始地址的引用指针，也可能是代表对象的句柄或其他于此对象相关的位置。 |
| returnAddress类型 | 指向了一条字节码指令的地址。                                 |

**✨注意点:**

1. 对象引用存放在栈中的局部变量表中，具体对象是存储在堆上的。
2. 基础类型是直接存储在栈中的局部变量表的。``包装类是对象所以引用和值是分开存的, 如上一条。``

##### 2.1.2 动态连接

##### 2.1.3 方法出口

##### 2.1.4 操作数栈

存放指令指向时所需数据的位置，指令从操作数栈中取走数据并将操作后的结果重新入栈。

### ③ 本地方法栈

> **线程私有**
>
> 为虚拟机使用``Native方法服务``。

本地方法栈类似于虚拟机栈，区别只是虚拟机栈服务于java方法，本地方法栈服务于Native方法。

``StackOverflowError``

- 栈深度溢出时抛出。

``OutOfMemoryError``

- 栈扩展失败时抛出。

### ④ 堆

> **所有线程共享**。
>
> 虚拟机启动时创建，且是虚拟机所管理的最大一块内存，唯一的``目的就是存放对象实例``。
>
> ⚠️**堆中存储的只可能是对象实例和数组**, 凡是``new``则都需要创建对象在堆中分配内存。

Java堆是``垃圾收集器(Garbage Collected)``所管理的内存区域，'几乎'所有的对象对象实例都在这里分配内存。人送小名``GC堆``。

这里的‘几乎’是由于随着即时编译技术的进步，尤其是逃逸分析技术的日渐强大，出现了**栈上分配、标量替换**等优化手段。

现代垃圾收集器大部分都是基于分代收集理论设计的。以经典分代为例：

- 新生代: 一个Eden和两个Survivor。
- 老年代
- ~~永久代~~: HotSpot早期方法区，其他虚拟机并不存在, JDK 6准备计划放弃，JDK 7开始实行，JDK 8 时被元空间替代。

---

### ⑤ 方法区

> **线程共享**
>
> 在不同的JVM上方法区是有区别的，这里以``HotSpot``为例介绍。

方法区在无法满足新的内存分配是，将抛出``OutOfMemoryError``异常

#### 5.1. JDK版本差异(HotSpot)

早期HotSpot使用永久代的方式实现了方法区, 其他虚拟机并不存在永久代这一个概念。

##### JDK6及之前版本

此时HotSpot中 方法区=永久代。存储被虚拟机加载的``类型信息``、``常量``、~~``静态变量``~~、``即时编译器编译后的代码缓存``等数据。

##### JDK7版本

从JDK 7开始弱化永久代，将后续准备不再存放在方法区中的``字符串常量池``和``静态变量``移动到了``Java堆``中。其他的依然还在永久代中。

> 主要是整理规划存储内容。

##### JDK8及以后版本

JDK 8 时完全废弃了永久代，改用在本地内存中实现的``元空间(Meta-Space)`` 来替代。

>  只是改变了实现方式，存储的内容并没有变, 同JDK7。

#### 5.2. 运行时常量池

Class文件的常量池表用于 **存放编译期生成的各种字面量和符号引用**，这部分内容将在 **类加载后存放到方法区的运行时常量池中**。

运行时常量池具备动态性：除了编译期产生外，运行期间也能将新的常量放入池中。

>  Class文件包含类的版本、字段、方法、接口等描述信息以及常量池表。[Class文件格式、符号引用后续单独补充]()

---

## 二、直接内存

直接内容并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。所以直接内存的分配**不受Java堆大小限制**，**只受设备总内存大小以及处理器寻址空间的限制**。各个内存区域和大于物理内存限制时，从而将导致动态扩展时出现OOM。

> JDK1.4时引入的NIO, 可以使用Native函数库直接分配堆外内存，避免了在Java堆和Native堆中来回复制数据。



# 参考资料

> **深入理解Java虚拟机（第3版）**📚
