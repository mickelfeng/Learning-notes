# 算法基础

## 复杂度分析

### 时间复杂度

> 在小规模数据面前, O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。因为此时省略的低阶、系数和常数的影响将会放大。

* O(1)：常量级
* O(n)：线性复杂度
* O(n^2)：指数复杂度
* O(logn): 对数复杂度

### 空间复杂度

## 有序度和逆序度

* 有序度：表示一组数据的有序程度。将队列中每个数后面比当前数小的数的个数之和。
* 逆序度：表示一组数据的无序程度。
* 完全有序/完全逆序 计算公式：n(n-1)/2

例如  `1、2、3`。

有序度：3；完全有序：2 + 1 + 0;（1，2）（1，3）（2，3）

逆序度：0

例如  `1、2、5、3`。

有序度：5；（1，2）（1，5）（1，3）（2，5）（2，3）

逆序度：1；有 (5，3) 

## 算法思想

### 贪心

贪心的核心思想就是 每次都保证局部最优，从而推导全局最优。但不能保证一定是全局最优，主要是由于前一个选择会影响后面的选择。

* 背包
* 分糖果
* 霍夫曼编码

### 分治

分治的核心思想就是 分而治之。将一个大问题划**分解**为多个结构相同彼此独立的小问题，可以递归来**处理**这些小问题，得到各自结果后进行**合并**，得到最终结果。

* 原问题可以被分解成具有相同模式的子问题。
* 子问题可以单独求解，且彼此独立。
* 存在边界值，不会出现无限分解的情况。
* 子问题可以合并回原问题，且合并操作复杂度较低。

### 回溯

时间复杂度：指数级很高，O(2^n)。

空间复杂度：

结合 备忘录，用空间换时间可以去除重复计算降低时间复杂度，接近动态规划。



### 动态规划

时间复杂度：O(n*w)

空间复杂度：O(n*w)

动态规划用于解决最优问题。

* 最优子结构：问题的最优解包含子问题的最优解；后面阶段的状态可以通过前面阶段的状态推导出来。
* 无后效性：阶段的状态确定后，不会受后面阶段的影响。
* 重复子问题：不同的决策序列，到达某个阶段后，可能会产生重复的状态。





## 排序算法

| 排序算法 | 时间复杂度                  | 空间复杂度 | 稳定排序？ | 原地排序？ |
| -------- | --------------------------- | ---------- | ---------- | ---------- |
| 冒泡排序 | O(n^2)                      |            | Y          | Y          |
| 插入排序 | O(n^2)                      |            | Y          | Y          |
| 选择排序 | O(n^2)                      |            | N          | Y          |
| 快速排序 | O(n logn), 最坏退化为O(n^2) | O(1)       | N          | Y          |
| 归并排序 | O(n logn)                   | O(n)       | Y          | N          |
| 计数排序 | O(n + k)，k是数据范围       |            | Y          | N          |
| 桶排序   | O(n)                        |            | Y          | N          |
| 基数排序 | O(d n), d是维度             |            | Y          | N          |

### 插入排序

循环不变式

> 元素A[1..j-1]就是原来在位置1到j-1的元素，但已按序排列

- 初始化：循环的第一次迭代之前，它为真。
- 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。
- 终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法时正确的。

### 归并排序

核心思想是分治。

将一个大问题**分解**为一个个小问题处理，最后再**合并**结果。



###  快速排序

最常见的排序算法之一，Java 的 `Arrays.sort()` 就是快速排序。

核心思想就是分治：

* 对于数组[p, r]，首先选择某个分区点 pivot。
* 遍历 数组[p, r]，将小于 pivot的放在左边，大于pivot 的放在右边。
* 递归处理左右分区的数据。



> 分区选择优化

* 三数取中法；

  首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。数组比较大时，取数需要更多，5数、10数等。

* 随机法；

  随机选择一个元素作为分区点，每次都选中最差分区的情况不太可能出现。

> 递归优化

* 限制递归层级；

* 自己实现堆上栈；

  手动模拟递归，越过系统栈大小的限制；

## 查找算法

|          | 时间复杂度 |      |
| -------- | ---------- | ---- |
| 二分查找 | O(logn)    |      |
|          |            |      |
|          |            |      |

### 二分查找（Binary Search）

> 折半查找算法
>
> 在链表中的`跳表`可以支持类似二分的查找算法

* 顺序表结构
* 有序数据集合

> 二分查找变形问题、

* 查找第一个值等于给定值的元素
* 查找最后一个值等于给定值的元素
* 查找第一个大于等于给定值的元素
* 查找最后一个小于等于给定值的元素

## 哈希算法

> 将任意长度的二进制值串映射为固定长度的二进制值串。

### 哈希算法的要求

* **单向推导：**从哈希值不能反推出原始数据（也叫单向哈希算法）。
* **数据敏感**：对于不同的输入数据，哪怕仅相差一个Bit，得到的哈希值也大不相同。
* **散列冲突概率低**：鸽巢原理
* **高效执行：**针对大量文本也能快速的计算出哈希值。

### 哈希算法的应用

* 安全加密：例如 **MD5**（MD5 Message-Digest Algorithm，MD5 消息摘要算法）、**SHA**（Secure Hash Algorithm，安全散列算法）、**DES**（Data Encryption Standard，数据加密标准）、**AES**（Advanced Encryption Standard，高级加密标准）等。
* 唯一标识：例如图库搜索图片
* 数据校验
* 散列函数：偏向于数据的平均性和执行效率。
* 负载均衡：客户端IP计算哈希，并根据服务器数量取模分配。
* 数据分片：使用哈希对海量数据进行分片，多机分布式处理。类同负载均衡。
* 分布式存储：一致性哈希算法。

### 一致性哈希算法

> 背景：在分布式缓存中，我们通过取模的方式将哈希值分布到不同服务器上，若此时需要进行扩容/缩容时，所有数据都需要重新计算哈希值。
>
> 那么就会导致所有数据请求都会穿透缓存，直接请求数据库，可能出现雪崩效应，压垮数据库。

一致性哈希算法通过将**数据的哈希划分为n个区间（尽可能大）**，并将这些区间分配给m台设备管理，**每台负责`n/m`个区间**。当有新的设备加入时，只需要**将部分区间数据搬迁到新的设备**即可，不需要全部重新哈希计算。



## 字符串匹配算法

常见的字符串匹配算法有 BF、RK、BM、KMP、AC 自动机、Trie等。

### BF

### RK

### BM算法

* **主串**：匹配过程中被匹配的内容，在这些内容中匹配查找我们需要的字符串。
  * 在字符串 `abcabd` 中查找 `abd`。即`abcabd` 就是主串
* **模式串**：匹配过程中我们需要匹配查找的内容。
  * 在字符串 `abcabd` 中查找 `abd`。 `abd`就是模式串。
* **坏字符**：从后面开始不能匹配的字符。
  * 例如匹配到 `abc` 和 `abd`时 `c`、`d` 就是坏字符。

* **好前缀**：模式串和主串匹配过程中已经匹配的那些字符串。
  * 例如匹配到 `abc` 和 `abd`时 `ab`就是好前缀
* **好后缀**：坏字符后面那端匹配的字符串。
  * 例如在字符串 `abcad` 中查找 `abdad`。后面的`ad` 就是好后缀。

### KMP算法

若模式串中存在 前n个字符 = 后n个字符，例如在模式串`b[0, i]` 中存在 `b[0, i - n]` = `b[n, i]`。

名词概念：

* **前缀子串**：`b[0, i - n]` 
* **后缀子串**： `b[n, i]`
* **最长可匹配后缀子串**：好前缀的所有后缀字串中，最长的那一个。
* **最长可匹配前缀子串**：最长可匹配后缀子串，对应的前缀子串。
* **失效函数（next数组)**：存储的是 模式串 中每个前缀的最长可匹配前缀字串的结尾字符下标。
  * 例如 `ababc`。就会包括 `a`、`ab`、`aba`、`abab` 三个，指分别为 -1、-1、0、1。下标
  * -1表示不存在最长可匹配前缀字串。0是a的字符下标。1是b的字符下标


结论1：

假设 `b[0, i]` 的最长可匹配后缀字串是 `b[r, i]`，也就是说`b[0, i - r]` = `b[r, i]`。

那么它们各去除末尾相同位数后应该还是相等的，即`b[0, i - r - 1]`  = `b[r, i - 1]`。

且 `b[r, i - 1]` 是 `b[0, i - 1]` 的其中一个后缀子串。

* 若之前 `b[i - r] = b[i] ` 则 `b[r, i - 1]` 是  `b[r, i - 1]` 的最长可匹配后缀子串。否则就不一定是最长。





## 编码

### 定长编码

每个编码都使用的相同位数表示。

### 前缀编码（前缀树）11

对字符集进行编码时，要求字符集中的任意字符的编码都不是其他字符编码的前缀。

使用前缀树来表示，根节点不包含字符，从根节点到叶子节点的每条路径都代表一个唯一编码，它们的长度也可能是不同的。

### 哈夫曼编码（哈夫曼树）

哈夫曼编码不仅考察 存在多少不同字符编码， 还会考察字符出现的频次。

* 频次高的编码长度短，频次低的长度长。

哈夫曼树是一种 最优二叉树。

组建过程：

1. 将所有字符根据出现频次的高低放到优先级队列中。

2. 从优先级队列中取出 两个 最低频率的字符 A, B，组合成节点C，值为 AB频率之和。C作为 AB的父节点。

3. 将C放会优先级队列，重复第二步。直至队列为空。



