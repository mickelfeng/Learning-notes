# 设计模式

> what、where、when、why、how。
>
> 名称、别名、动机、结构、示例、效果、相关模式。
>
> 隔离变化，减少改动。

## 设计原则

### SOLID  5个原则

1. **SRP，单一原则**（Single Responsibility Principle）；

   功能明确单一，短小精悍。高内聚低耦合。（工厂、适配器、装饰、代理）

2. **OCP，开闭**（Open Closed Principle）；

   对扩展开发，对修改关闭。不必通过修改内部代码来实现外部的需求扩展。（桥接、迭代器）

3. **LSP，里氏替换**（Liskov Substitution Principle）；

   子类必须能完全的替代父类。

4. **ISP，接口隔离**（Interface-Segregation Principle）；

   简化、归并对外接口。（适配器、装饰、外观）

5. **DIP，依赖反转/依赖倒置**（Dependency Inversion Principle）；

   解耦依赖关系。（抽象工厂、桥接、适配器）

### DRY（Don’t Repeate Yourself）

避免重复

### KISS（Keep It Simple Stupid）

保持简洁

---

23种设计模式，可分为3大类

* 创建型模式
* 行为型模式
* 结构型模式

## 创建型模式

> 如何创建对象？
>
> 封装对象的创建过程，隔离对象的生产和使用。

### 抽象工厂

### 工厂方法

### 生成器

### 原型

### 单例/单件

---

## 行为模式

> 如何处理对象之间的动态通信和职责分配？
>
> 描述对象直接动态的消息传递，隔离程序里动态变化的部分。

### 职责链

将多个对象串联成一个**链条**，且每个对象都有机会取处理请求。请求通常是命令模式。

### 命令

### 策略

 不改变类的外部表现和内部状态。封装了不同的算法，可以在运行时灵活地互相替换算法模块，从而非侵入地改变系统的行为。

例如`if/else`等分支决策中，将分支分装成类或lambda表达式（**实现具体的策略**），然后放入对于的容器中（传入策略赋值），最后由容器内部选择合适的策略处理（**动态执行策略**）。

### 解释器

### 迭代器

### 中介者

### 备忘录

### 状态

### 观察者

### 模板方法

### 访问者

---

## 结构型模式

> 如何组合对象？
>
> 以灵活、可拆卸、可装配的方式组合出新的对象，关注对象间的静态联系。
>
> 隔离了客户代码和原对象的接口，解决类间或者对象间关系复杂的问题。

### 适配器

主要目的是【接口转换】：通过适配器在不改动源码的前提下，将对象转换为本系统中适用的形式。

### 代理

包装一个对象，不允许外部直接和内部通讯，用代理对象控制内部真实对象执行操作。外部只需要知道代理对象即可。

主要目的是【控制】，内部持有【真实对象的引用】，我们都是通过代理对象来调用具体的功能接口。

* 内部对象不方便对外暴露，对外是透明的，它的对外的访问是由代理类控制的。
* 在代理的同时，隐式的扩展真实对象的功能。

### 外观/门面

封装一组对象，简化这组对象的通信关系，并提供一个高层次的易用接口，提供给外部使用，降低复杂度。

不屏蔽内部包装的那些对象。

### 桥接

### 组合（Composite）



### 装饰（Decorator）

装饰者模式主要目的是在 不改变对象接口的前提下**【强化】对象的功能**。是一个递归的构造。

装饰者模式和代理模式的主要区别是 目的不同，装饰者是为了强化功能，代理是为了访问控制。

意思就是：

* 在使用代理者模式，我们都是通过统一的代理类来调用具体的功能接口，实际访问对象对外是透明的，由代理类控制。
* 使用装饰者模式时，我们是使用的就是一个个具体的装饰类，这些类有各自的增强方法，都是可以直接对外访问。可以通过递归包装的方式进行访问。