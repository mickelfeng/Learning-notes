# 常见算法

## 字符串匹配算法

### BM算法

* **主串**：匹配过程中被匹配的内容，在这些内容中匹配查找我们需要的字符串。
  * 在字符串 `abcabd` 中查找 `abd`。即`abcabd` 就是主串
* **模式串**：匹配过程中我们需要匹配查找的内容。
  * 在字符串 `abcabd` 中查找 `abd`。 `abd`就是模式串。
* **坏字符**：从后面开始不能匹配的字符。
  * 例如匹配到 `abc` 和 `abd`时 `c`、`d` 就是坏字符。

* **好前缀**：模式串和主串匹配过程中已经匹配的那些字符串。
  * 例如匹配到 `abc` 和 `abd`时 `ab`就是好前缀
* **好后缀**：坏字符后面那端匹配的字符串。
  * 例如在字符串 `abcad` 中查找 `abdad`。后面的`ad` 就是好后缀。

### KMP算法

若模式串中存在 前n个字符 = 后n个字符，例如在模式串`b[0, i]` 中存在 `b[0, i - n]` = `b[n, i]`。

名词概念：

* **前缀子串**：`b[0, i - n]` 
* **后缀子串**： `b[n, i]`
* **最长可匹配后缀子串**：好前缀的所有后缀字串中，最长的那一个。
* **最长可匹配前缀子串**：最长可匹配后缀子串，对应的前缀子串。
* **失效函数（next数组)**：存储的是 模式串 中每个前缀的最长可匹配前缀字串的结尾字符下标。
  * 例如 `ababc`。就会包括 `a`、`ab`、`aba`、`abab` 三个，指分别为 -1、-1、0、1。下标
  * -1表示不存在最长可匹配前缀字串。0是a的字符下标。1是b的字符下标


结论1：

假设 `b[0, i]` 的最长可匹配后缀字串是 `b[r, i]`，也就是说`b[0, i - r]` = `b[r, i]`。

那么它们各去除末尾相同位数后应该还是相等的，即`b[0, i - r - 1]`  = `b[r, i - 1]`。

且 `b[r, i - 1]` 是 `b[0, i - 1]` 的其中一个后缀子串。

* 若之前 `b[i - r] = b[i] ` 则 `b[r, i - 1]` 是  `b[r, i - 1]` 的最长可匹配后缀子串。否则就不一定是最长。



## 完全二叉树

在堆排序中会使用完全二叉树

数组堆化

* 数组的第一个元素`array[0]`不存储数据。
* 堆中的第一个元素就是数组 `array[1]`。

### 完全二叉树中 父节点和子节点间的快速定位。假设 父节点位置为 i。

存在两种情况 序号从 0 开始：

```kotlin
val left = 2 * i + 1
val right = 2 * i + 2
```

序号从 1 开始：

```kotlin
val left = 2 * i
val right = array[2 * i + 1]
```

### 求完全二叉树最后一个非叶子节点

完全二叉树 长度为 n。

存在两种情况 序号从 0 开始：

```kotlin
val node = n >>> 1 - 1;
```

序号从 1 开始：

```kotlin
val node = n >>> 1;
```

## 贪心

贪心的核心思想就是 每次都保证局部最优，从而推导全局最优。但不能保证一定是全局最优，主要是由于前一个选择会影响后面的选择。

* 背包
* 分糖果
* 霍夫曼编码

## 分治

分治的核心思想就是 分而治之。将一个大问题划**分解**为多个结构相同彼此独立的小问题，可以递归来**处理**这些小问题，得到各自结果后进行**合并**，得到最终结果。

* 原问题可以被分解成具有相同模式的子问题。
* 子问题可以单独求解，且彼此独立。
* 存在边界值，不会出现无限分解的情况。
* 子问题可以合并回原问题，且合并操作复杂度较低。

回溯
