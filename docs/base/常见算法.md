# 常见算法

## 字符串匹配算法

### BM算法

### KMP算法

若模式串中存在 前n个字符 = 后n个字符，例如模式串`b[0, i]` 中 `b[0, i - r]` = `b[r, i]`。

其中 `b[r, i]`称为 **后缀子串**，前n个字符 `b[0, i - r]` 称为 **前缀子串**，。

* 最长可匹配后缀子串：后缀子串中最长的一个。
* 最长可匹配前缀子串：最长可匹配后缀子串，对应的前缀子串。



结论1：

假设 `b[0, i]` 的最长可匹配后缀字串是 `b[r, i]`，也就是说`b[0, i - r]` = `b[r, i]`。

可得`b[0, i - r - 1]`  = `b[r, i - 1]`。

所以 `b[r, i - 1]` 是 `b[0, i - 1]` 的其中一个后缀子串。

* 若之前 `b[i - r] = b[i] ` 则 `b[r, i - 1]` 是  `b[r, i - 1]` 的最长可匹配后缀子串。否则就不一定是最长。



## 完全二叉树

在堆排序中会使用完全二叉树

数组堆化

* 数组的第一个元素`array[0]`不存储数据。
* 堆中的第一个元素就是数组 `array[1]`。

### 完全二叉树中 父节点和子节点间的快速定位。假设 父节点位置为 i。

存在两种情况 序号从 0 开始：

```kotlin
val left = 2 * i + 1
val right = 2 * i + 2
```

序号从 1 开始：

```kotlin
val left = 2 * i
val right = array[2 * i + 1]
```

### 求完全二叉树最后一个非叶子节点

完全二叉树 长度为 n。

存在两种情况 序号从 0 开始：

```kotlin
val node = n >>> 1 - 1;
```

序号从 1 开始：

```kotlin
val node = n >>> 1;
```

