# 常见算法

## 字符串匹配算法

### BM算法

* **主串**：匹配过程中被匹配的内容，在这些内容中匹配查找我们需要的字符串。
  * 在字符串 `abcabd` 中查找 `abd`。即`abcabd` 就是主串
* **模式串**：匹配过程中我们需要匹配查找的内容。
  * 在字符串 `abcabd` 中查找 `abd`。 `abd`就是模式串。
* **坏字符**：从后面开始不能匹配的字符。
  * 例如匹配到 `abc` 和 `abd`时 `c`、`d` 就是坏字符。

* **好前缀**：模式串和主串匹配过程中已经匹配的那些字符串。
  * 例如匹配到 `abc` 和 `abd`时 `ab`就是好前缀
* **好后缀**：坏字符后面那端匹配的字符串。
  * 例如在字符串 `abcad` 中查找 `abdad`。后面的`ad` 就是好后缀。

### KMP算法

若模式串中存在 前n个字符 = 后n个字符，例如在模式串`b[0, i]` 中存在 `b[0, i - n]` = `b[n, i]`。

名词概念：

* **前缀子串**：`b[0, i - n]` 
* **后缀子串**： `b[n, i]`
* **最长可匹配后缀子串**：好前缀的所有后缀字串中，最长的那一个。
* **最长可匹配前缀子串**：最长可匹配后缀子串，对应的前缀子串。
* **失效函数（next数组)**：存储的是 模式串 中每个前缀的最长可匹配前缀字串的结尾字符下标。
  * 例如 `ababc`。就会包括 `a`、`ab`、`aba`、`abab` 三个，指分别为 -1、-1、0、1。下标
  * -1表示不存在最长可匹配前缀字串。0是a的字符下标。1是b的字符下标


结论1：

假设 `b[0, i]` 的最长可匹配后缀字串是 `b[r, i]`，也就是说`b[0, i - r]` = `b[r, i]`。

那么它们各去除末尾相同位数后应该还是相等的，即`b[0, i - r - 1]`  = `b[r, i - 1]`。

且 `b[r, i - 1]` 是 `b[0, i - 1]` 的其中一个后缀子串。

* 若之前 `b[i - r] = b[i] ` 则 `b[r, i - 1]` 是  `b[r, i - 1]` 的最长可匹配后缀子串。否则就不一定是最长。



## 完全二叉树

在堆排序中会使用完全二叉树

数组堆化

* 数组的第一个元素`array[0]`不存储数据。
* 堆中的第一个元素就是数组 `array[1]`。

### 完全二叉树中 父节点和子节点间的快速定位。假设 父节点位置为 i。

存在两种情况 序号从 0 开始：

```kotlin
val left = 2 * i + 1
val right = 2 * i + 2
```

序号从 1 开始：

```kotlin
val left = 2 * i
val right = array[2 * i + 1]
```

### 求完全二叉树最后一个非叶子节点

完全二叉树 长度为 n。

存在两种情况 序号从 0 开始：

```kotlin
val node = n >>> 1 - 1;
```

序号从 1 开始：

```kotlin
val node = n >>> 1;
```

---

## 编码

### 定长编码

每个编码都使用的相同位数表示。

### 前缀编码

对字符集进行编码时，要求字符集中的任意字符的编码都不是其他字符编码的前缀。

使用前缀树来表示，根节点不包含字符，从根节点到叶子节点的每条路径都代表一个唯一编码，它们的长度也可能是不同的。

### 哈夫曼编码

哈夫曼编码不仅考察 存在多少不同字符编码， 还会考察字符出现的频次。

* 频次高的编码长度短，频次低的长度长。

哈夫曼树是一种 最优二叉树。

组建过程：

1. 将所有字符根据出现频次的高低放到优先级队列中。

2. 从优先级队列中取出 两个 最低频率的字符 A, B，组合成节点C，值为 AB频率之和。C作为 AB的父节点。

3. 将C放会优先级队列，重复第二步。直至队列为空。





---

## 贪心

贪心的核心思想就是 每次都保证局部最优，从而推导全局最优。但不能保证一定是全局最优，主要是由于前一个选择会影响后面的选择。

* 背包
* 分糖果
* 霍夫曼编码

## 分治

分治的核心思想就是 分而治之。将一个大问题划**分解**为多个结构相同彼此独立的小问题，可以递归来**处理**这些小问题，得到各自结果后进行**合并**，得到最终结果。

* 原问题可以被分解成具有相同模式的子问题。
* 子问题可以单独求解，且彼此独立。
* 存在边界值，不会出现无限分解的情况。
* 子问题可以合并回原问题，且合并操作复杂度较低。

## 回溯

时间复杂度：指数级很高，O(2^n)。

空间复杂度：

结合 备忘录，用空间换时间可以去除重复计算降低时间复杂度，接近动态规划。



## 动态规划

时间复杂度：O(n*w)

空间复杂度：O(n*w)

动态规划用于解决最优问题。

* 最优子结构：问题的最优解包含子问题的最优解；后面阶段的状态可以通过前面阶段的状态推导出来。
* 无后效性：阶段的状态确定后，不会受后面阶段的影响。
* 重复子问题：不同的决策序列，到达某个阶段后，可能会产生重复的状态。



## 并查集

### 基础

并查集是一种树型的数据结构，常用于处理一些**不相交集合的合并于查询问题**。

* 合并两个元素所在集合：分别找到两个元素所在根节点，然后将其中一个集合的根节点作为另一个集合的根节点的父节点。
* 查询两个元素是否属于同一个集合：分别查找两个元素的根节点，然后比对根节点是否相同，相同就属于同一个结合。

时间复杂度取决于 树的深度 O(h)。

> 路径压缩进行优化：每次查询时将沿途经过的节点的父节点改为根节点。最好情况下，时间复杂度变为 O(1)

### 带权并查集

两个元素建立连接时，不仅仅是将两个元素所在集合进行合并，而且还需要设置一个权值来表示它们间的关系。

> 带权并查集 进行路径压缩优化时，需要重新计算标注权值。
