# 数据结构与算法

## 伪代码

- 缩进表示块结构。

- while、for与repeat-until等循环结构以及if-else等条件语句机构与C、C++、Java、Python和Pascal中的那些机构具有类似的解释。

  ```
  to：迭代递增
  downto：迭代递减
  by：指定增量， by 2
  ```

- 符号``//``表示该行后面部分为注释。

- 形如i=j=e的多重赋值将表达式e的值赋给变量i和j。

  ```
  j = e;
  i = j;
  ```

- 变量是局部给定过程的。若无显示说明，不使用全局变量。

- 数组元素通过``数组名[下标]``的形式来访问。

  ```
  A[i] 表示 数组A的第i个元素。
  .. 表示数组值的一个范围,
  A[1..j] 表示A的一个子数组。
  ```

- 复合数据通常被组织称``对象``,对象又由``属性``组成。

  ```
  . 后跟一个 属性名。例如：A.length
  我们把表示一个数组或对象的变量看作指向表示数组或对象的数据的一个指针。
  ```

- ``按值``把参数传递给过程：被调用过程接收其参数自身的副本。

  ```
  如果对某个参数赋值，调用过程看不到这种改变。即参数重新赋值对原始参数并没有影响。
  当对象被传递时，指向表示对象数据的指针被复制，而对象的属性并未被复制。即改变对象的属性时，原始对象内的属性也将会被改变。
  数组同对象。
  ```

- 一个reutrn语句立即将控制返回到调用过程的调用点。

- 布尔运算符``and``和``or``都是**短路的**。

  ```
  即 x and y，若 x 为 false，则不再求值y。
  x or y，若 x 为 true， 则不再求值y。
  ```

- 关键词``error``表示因为已被调用的过程情况不对而出现了一个错误。


## 分析算法

### RAM模型

假定为单处理器，指令一条接一条地执行，没有并发操作。

- 算术指令

  ```
  加法、减法、乘法、除法、其余、向下取整、向上取整
  ```

- 数据移动指令

  ```
  装入、存储、复制
  ```

- 控制指令

  ```
  条件与无条件转移、子程序调用与返回
  ```

---

## 数据结构

### 1、 线性表

#### 数组和矩阵

> 连续空间

优点

- 存取速度快

缺点

- 需要事先设置数组的长度。
- 需要连续的大块内存，且大小固定。
- 插入/删除节点慢。


#### 链表

优点

- 插入删除速度快。
- 空间没有限制，也不必事先知道大小。

缺点
- 存取速度慢。

> 链表的类型：

| 类型     |                                    |                                    |
| -------- | ---------------------------------- | ---------------------------------- |
| 单向链表 | 一个节点指向下一个节点。           |                                    |
| 双向链表 | 一个节点有2个指针域。              |                                    |
| 循环链表 | 链表的最后一个节点指向第一个节点。 | 能通过任意一个节点找到所有的节点。 |

#### 跳表（Skip list）

> 一种`动态数据结构`，核心就是空间换时间，通过**链表 + 多级索引**的方式减少查询次数。
>
> 可以支持类似二分的查找算法，甚至可以替代红黑树（Red-black tree）。
>
> Redis 中的有序集合（Sorted Set）就是用跳表来实现的。

* 链表加多级索引，减少查询次数。
* 支持快速插入、删除、查找操作，时间复杂度为O(logn)。

**结构图：**

> 每两个节点(也可每3个、4个)提取一个节点，建立多级`索引层`，通过`down指针`指向下一级。此时索引层每层最多遍历3次。
>
> 查找时先从索引层开始，依次往下遍历。

![跳表](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/%E8%B7%B3%E8%A1%A8.png)

跳表索引的动态更新：

> 往跳表中插入数据时，若不更新索引，某2个结点间的数据将很多，甚至退化成单链表。

通过随机函数来维护索引和原始链表大小的平衡。随机生成k, 将结点添加到 `1~k级索引`中。

#### 散列表（Hash Table）

> 基于数组支持按照下表随机访问数据的特性扩展而来。
>
> 时间复杂度正常情况O(1)，可能退化为O(n)。
>
> 散列表大小发生变化时，所以需要重新调用散列函数计算位置。

| 概念                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| Key                      | 关键字                                                       |
| Value                    | 需要存储的数据                                               |
| 散列函数/hash(key)       | 将Key转换为散列值（数组下标）                                |
| 散列值/Hash 值           | 散列函数计算得到的值                                         |
| 散列冲突                 | 不同的key值经过散列函数计算却得到相同的hash值的情况。        |
| 装载因子（load factor）  | ` 装载因子 = 表中元素个数/散列表的长度`。该值越大，表示数据越多，空位越少，散列冲突可能性将越大，性能损失越大。使用链表法时装载因子可能大于1。 |
| 桶（bucket）/ 槽（slot） | 表示散列表中的一个存储位置。                                 |

存储数据（暂不考虑散列冲突）：输入`key` 和`value`，通过**散列函数**将`Key`映射为数组的下标，然后将数据存储在数组对应的下标中。

查询数据（暂不考虑散列冲突）：输入`key` ，同样通过**散列函数**将`Key`映射为数组的下标，从对应的数组中返回数据。

![散列表](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/%E6%95%A3%E5%88%97%E8%A1%A8.png)

##### 散列函数

> 设计方法：数据分析法、直接寻址法、平方取中法、折叠法、随机数法等

1. 计算得到一个非负整数（数组下标）。
2. 若key1 == key2，则hash(key1) == hash(key2)。
3. 若key1 != key2，则hash(key1) != hash(key2)。

优化：

可以通过`动态扩容`的方式优化装载因子过大的情况，装载因子过小时也可以通过`动态缩容`的方式优化空间，由于大小发生变化，所以需要重新调用散列函数计算位置。



##### 散列冲突

> 基于鸽巢原理，存在固定n个鸽巢，有n+1只鸽子，那么必然出现2只鸽子在同一个鸽巢里面。
>
> 鸽巢就是哈希值长度，鸽子就是key。哈希算法产生的哈希值长度是固定的，所以可能出现 key1 != key2，而hash(key1) == hash(key2)的情况。
>
> 常用的冲突解决方式有：`开放寻址法`和`链表法`。

**1. 开放寻址法（open addressing）**

出现了散列冲突，就重新探测一个空闲位置，将其插入。

* 所有数据都在数组中，内存是连续的，可以有效地利用 CPU 缓存加快查询速度。
* 序列化方便。
* 大数据量情况下更容易发生冲突：随数据越来越多，冲突将的可能性将递增，空闲位置越来越少，探测时间递增。最坏情况时间复杂度将退化为O(n)，适用于数据量较小的场景。
* 内存利用率低：更加容易发生冲突，装载因子不能设置过大，从而浪费内存空间。

> 线性探测（Linear Probing）：步长 hash(key) + n。
>
> Java 中的 ThreadLocalMap

插入数据：当往散列表中插入数据时，根据`散列值`找到数组对应位置，空闲则存入。若存储位置已被占用，则从当前位置依次往后开始查找，直到找到空闲位置。

查询数据：根据`散列值`找到数组对应位置，比较该位置的key是否匹配，匹配则返回。若不匹配就需要顺序往后依次查询并匹配key，如果遍历到空闲位置也没有找到，表示不在散列表中。

删除操作：由于线性探测的特性，查询时遍历到空闲位置会被认定数据不存在，所以被删除的元素会被`标记为deleted`，而不是直接删除。

> 二次探测（Quadratic probing）

类似线性探测，探测步长不同，步长为` hash(key) + n^2`

> 双重散列（Double hashing）

使用**一组散列函数**，若通过第一个函数得到的位置已被占用，则使用第二个散列函数，依次类推，直到找到空闲位置。

**2. 链表法（chaining）**

> Java 中的 HashMap，底层通过数组+链表+红黑树。
>
> LinkedHashMap

每个槽位对应一个链表。所有散列值相同的元素都放在相同槽位的链表中。

* 适用于大规模数据。
* 内存占用变多。不过对较小对象数据的存储，由于多出了结点指针，可能导致内存消耗翻倍。大对象数据时则可忽略影响。
* 内存不连续，对CPU缓存不友好。
* 需要尽可能让散列值均匀分布，防止时间复杂度退化。

> 散列表碰撞攻击
>
> 恶意的攻击者通过精心构造的数据，使得所有数据在散列函数计算后，都落到相同的槽中。此时散列表退化为链表，查询的时间复杂度变为O(n)，导致查询耗时大大增加，系统可能无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。
>
> 可以将链表改造为其他数据结构（例如跳表、红黑树等）进行优化，避免退化为O(n)。

##### 散列表的应用

* LRU缓存淘汰策略：散列表 + 双向链表
* Redis有序集合：跳表 + 散列表
* LinkedHashMap：散列表 + 双向链表，原理同LRU缓存淘汰策略。

### 2、树（Tree）

> 存储方式
>
> 1. 基于指针或者引用的二叉链式存储法。
>
> 2. 基于数组的顺序存储法。

A为**根节点**，它没有父节点。

A是B、E的**父节点**，BE互为**兄弟节点**。

CDE叫做**叶子节点（叶节点）**，它们没有字节点。

* **节点的高度：**节点到叶子节点的**最长路径（边数**），例如 heightA = 2；heightB = 1。从上往下递减。
* **节点的深度：**根节点到节点的所经过的边数。depthA = 0；depthB = 1。从上往下递增。
* **节点的层数：**节点深度 + 1。levelA = 1；levelB = 2。从上往下递增。
* **树的高度：**等同 根节点的高度。此处为2。从上往下递减。

![树](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/%E6%A0%91.png)

#### 二叉树

>  每个节点**最多两个**子节点：左子节点和右子节点。

##### 满二叉树

> 特殊的完全二叉树

* 叶子节点都在最底层。
* 除叶子节点外，都有两个子节点。

##### 完全二叉树

* 叶子节点都在最后两层。
* 最后一层所有叶子节点都靠左排列（左对齐、连续）。
* 除最后一层外，其他层节点个数都达到最大。

##### 树的遍历

* 前序遍历：对于树中任意节点，先打印这个**节点自身**，再打印左子树，最后打印**右子树**。
* 中序遍历：对于树中任意节点，先打印**左子树**，再打印**节点自身**，最后打印**右子树**。
* 后序遍历：对于树中任意节点，先打印**左子树**，再打印**右子树**，最后这个**节点自身**。

#### 二叉查找树（Binary Search Tree）

> 二叉搜索树

特点

- **左子树**上的所有节点的值均**<=父节点**的值。
- **右子树**上的所有节点的值均**>=父节点**的值。
- 左右子树也为满足上述条件的二叉搜索树。

> 查找流程

* 首先和根节点比较，如果相等直接返回。

* 若**数据比节点小**，则从**左子树中递归**搜索。

* 若**数据比节点大**，则从**右子树中递归**搜索。

> 插入流程

* 执行查找流程

* 若**数据比节点大**且节点的**右子树为空**，则直接将新数据**插入右子节点**位置。若不为空，**则递归遍历右子树**，查找合适位置。
* 若**数据比节点小**且节点的**左子树为空**，则直接将新数据**插入左子节点**位置。若不为空，**则递归遍历左子树**，查找合适位置。

> 时间复杂度

| 操作 | 最优 | 一般 | 最坏 |
| ---- | ---- | ---- | ---- |
| 查找 |      |      | O(N) |
| 插入 |      |      | O(N) |
| 删除 |      |      | O(N) |

> 查找操作



最坏场景：O(N)

>  插入 9、10、11

![image-20220530143106188](数据结构与算法.assets/image-20220530143106188-3892268.png)

>  旋转操作

- 左旋
- 右旋



#### 平衡树

> 时间复杂度

| 操作 | 最优 | 一般    | 最坏 |
| ---- | ---- | ------- | ---- |
| 查找 |      | O(logN) |      |
| 插入 |      | O(logN) |      |
| 删除 |      | O(logN) |      |



#### 234树/4阶B树

- 是一种多叉树
- 每个节点最多有``3个数据项``和``4个字节点``。

![image-20220530143729600](数据结构与算法.assets/image-20220530143729600-3892651.png) 插入操作：``上溢``。

删除操作：``下溢``。



#### 红黑树

> 一种高效的自平衡二叉搜索树

- 节点是红色或黑色。
- 根节点是黑色。
- 叶子节点都为黑色，且都为空。
- 红色节点的父节点和字节点都为黑色(不会存在2个连续的红色节点)。
- 从任一节点到叶子节点到所有路径都包含相同的数量的黑色节点。

> 红黑树和234树是等价

- 红黑树的黑色节点个树 = 234树的节点数
- 234树的每一个节点中：黑色节点必为父节点，红色节点为字节点（黑色终结，红色两边）。



##### 插入操作的12种情况

> 如果插入的是根节点，则为黑色。
>
> 其余情况插入的节点``最开始都一定是红色``（出现连续两个红色节点的冲突情况时需要进行旋转和变化）。

- 插入节点的父节点为黑色（4种）：直接插入，不做调整。
- 叔父节点不是红色（4种）：变色 + 旋转。
- 叔父节点时红色（4种上溢）：变色。



## 算法基础

### 1、 复杂度分析

#### 时间复杂度

> 在小规模数据面前, O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。因为此时省略的低阶、系数和常数的影响将会放大。

* O(1)：常量级
* O(n)：线性复杂度
* O(n^2)：指数复杂度
* O(logn): 对数复杂度

#### 空间复杂度



### 2、 排序算法

| 排序算法 | 时间复杂度                  | 空间复杂度 | 稳定排序？ | 原地排序？ |
| -------- | --------------------------- | ---------- | ---------- | ---------- |
| 冒泡排序 | O(n^2)                      |            | Y          | Y          |
| 插入排序 | O(n^2)                      |            | Y          | Y          |
| 选择排序 | O(n^2)                      |            | N          | Y          |
| 快速排序 | O(n logn), 最坏退化为O(n^2) | O(1)       | N          | Y          |
| 归并排序 | O(n logn)                   | O(n)       | Y          | N          |
| 计数排序 | O(n + k)，k是数据范围       |            | Y          | N          |
| 桶排序   | O(n)                        |            | Y          | N          |
| 基数排序 | O(d n), d是维度             |            | Y          | N          |

#### 插入排序

循环不变式
> 元素A[1..j-1]就是原来在位置1到j-1的元素，但已按序排列
- 初始化：循环的第一次迭代之前，它为真。
- 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。
- 终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法时正确的。

####  快速排序

> 分区选择优化

* 三数取中法；

  首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。数组比较大时，取数需要更多，5数、10数等。

* 随机法；

  随机选择一个元素作为分区点，每次都选中最差分区的情况不太可能出现。

> 递归优化

* 限制递归层级；

* 自己实现堆上栈；

  手动模拟递归，越过系统栈大小的限制；

### 3、查找

|          | 时间复杂度 |      |
| -------- | ---------- | ---- |
| 二分查找 | O(logn)    |      |
|          |            |      |
|          |            |      |

#### 二分查找（Binary Search）

> 折半查找算法
>
> 在链表中的`跳表`可以支持类似二分的查找算法

* 顺序表结构
* 有序数据集合

> 二分查找变形问题、

* 查找第一个值等于给定值的元素
* 查找最后一个值等于给定值的元素
* 查找第一个大于等于给定值的元素
* 查找最后一个小于等于给定值的元素

### 4、哈希（Hash）算法

> 将任意长度的二进制值串映射为固定长度的二进制值串。

#### 哈希算法的要求

* **单向推导：**从哈希值不能反推出原始数据（也叫单向哈希算法）。
* **数据敏感**：对于不同的输入数据，哪怕仅相差一个Bit，得到的哈希值也大不相同。
* **散列冲突概率低**：鸽巢原理
* **高效执行：**针对大量文本也能快速的计算出哈希值。

#### 哈希算法的应用

* 安全加密：例如 **MD5**（MD5 Message-Digest Algorithm，MD5 消息摘要算法）、**SHA**（Secure Hash Algorithm，安全散列算法）、**DES**（Data Encryption Standard，数据加密标准）、**AES**（Advanced Encryption Standard，高级加密标准）等。
* 唯一标识：例如图库搜索图片
* 数据校验
* 散列函数：偏向于数据的平均性和执行效率。
* 负载均衡：客户端IP计算哈希，并根据服务器数量取模分配。
* 数据分片：使用哈希对海量数据进行分片，多机分布式处理。类同负载均衡。
* 分布式存储：一致性哈希算法。

#### 一致性哈希算法

> 背景：在分布式缓存中，我们通过取模的方式将哈希值分布到不同服务器上，若此时需要进行扩容/缩容时，所有数据都需要重新计算哈希值。那么所有数据请求都会穿透缓存，直接请求数据库，可能出现雪崩效应，压垮数据库。

一致性哈希算法通过将**数据的哈希划分为n个区间（尽可能大）**，并将这些区间分配给m台设备管理，**每台负责`n/m`个区间**。当有新的设备加入时，只需要**将部分区间数据搬迁到新的设备**即可，不需要全部重新哈希计算。
