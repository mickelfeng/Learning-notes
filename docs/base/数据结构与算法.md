# 数据结构与算法

## 1 数据结构

### 1.1 线性表

#### 数组和矩阵

> 连续空间

| 随机访问 | 插入删除 |
| -------- | -------- |
| O(1)     | O(n)     |

优点

- 存取速度快

缺点

- 需要事先设置数组的长度。
- 需要连续的存储空间，且大小固定。
- 插入/删除结点慢。

#### 链表

通过指针链接次序。

- 插入删除速度快。
- 非连续、非顺序的存储结构
- 空间没有限制，也不必事先知道大小。

缺点
- 存取速度慢。

> 链表的类型：

| 类型     |                                              |                                                              |
| -------- | -------------------------------------------- | ------------------------------------------------------------ |
| 单向链表 | 数据域 + 一个指针域。                        | 一个存储数据元素的数据域 和 一个存储下一个结点地址的指针域（**后继指针**）组成。 |
| 双向链表 | 数据域 + 两个指针域。                        | 在单链表的结果上，增加了一个存储上一个结点地址的指针域（**前驱指针**）。Java的`LinkedHashMap` |
| 循环链表 | 单链表 or 双向链表，**尾结点指针指向头结点** | 能通过任意一个节点找到所有的结点。                           |

#### 静态链表

> 用数组表述链表。

数组的每个元素都有**2个数据域**构成，一个存储**数据元素（data）**，一个存储**游标（cur）**,相当于单链表中的next指针。



#### 跳表（Skip list）

> 一种`动态数据结构`，核心就是空间换时间，通过**链表 + 多级索引**的方式减少查询次数。
>
> 可以支持类似二分的查找算法，甚至可以替代红黑树（Red-black tree）。
>
> Redis 中的有序集合（Sorted Set）就是用跳表来实现的。

* 链表加多级索引，减少查询次数。
* 支持快速插入、删除、查找操作，时间复杂度为O(logn)。
* 空间复杂度：O(n)，适用于不太在意内存空间的场景。

**结构图：**

> 每两个节点(也可每3个、4个)提取一个节点，建立多级`索引层`，通过`down指针`指向下一级。此时索引层每层最多遍历3次。
>
> 查找时先从索引层开始，依次往下遍历。

![跳表](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/%E8%B7%B3%E8%A1%A8.png)

跳表索引的动态更新：

> 往跳表中插入数据时，若不更新索引，某2个结点间的数据将很多，甚至退化成单链表。

通过随机函数来维护索引和原始链表大小的平衡。随机生成k, 将结点添加到 `1~k级索引`中。

#### 散列表（Hash Table）

> 基于数组支持按照下表随机访问数据的特性扩展而来。
>

* 时间复杂度正常情况O(1)，可能退化为O(n)。
* 散列表大小发生变化时，需要重新调用散列函数计算位置，以及扩容缩容带来性能损耗。
* 不能顺序遍历。

| 概念                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| Key                      | 关键字                                                       |
| Value                    | 需要存储的数据                                               |
| 散列函数/hash(key)       | 将Key转换为散列值（数组下标）                                |
| 散列值/Hash 值           | 散列函数计算得到的值                                         |
| 散列冲突                 | 不同的key值经过散列函数计算却得到相同的hash值的情况。        |
| 装载因子（load factor）  | ` 装载因子 = 表中元素个数/散列表的长度`。该值越大，表示数据越多，空位越少，散列冲突可能性将越大，性能损失越大。使用链表法时装载因子可能大于1。 |
| 桶（bucket）/ 槽（slot） | 表示散列表中的一个存储位置。                                 |

存储数据（暂不考虑散列冲突）：输入`key` 和`value`，通过**散列函数**将`Key`映射为数组的下标，然后将数据存储在数组对应的下标中。

查询数据（暂不考虑散列冲突）：输入`key` ，同样通过**散列函数**将`Key`映射为数组的下标，从对应的数组中返回数据。

![散列表](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/%E6%95%A3%E5%88%97%E8%A1%A8.png)

##### 散列函数

> 设计方法：数据分析法、直接寻址法、平方取中法、折叠法、随机数法等

1. 计算得到一个非负整数（数组下标）。
2. 若key1 == key2，则hash(key1) == hash(key2)。
3. 若key1 != key2，则hash(key1) != hash(key2)。

优化：

可以通过`动态扩容`的方式优化装载因子过大的情况，装载因子过小时也可以通过`动态缩容`的方式优化空间，由于大小发生变化，所以需要重新调用散列函数计算位置。



##### 散列冲突

> 基于鸽巢原理，存在固定n个鸽巢，有n+1只鸽子，那么必然出现2只鸽子在同一个鸽巢里面。
>
> 鸽巢就是哈希值长度，鸽子就是key。哈希算法产生的哈希值长度是固定的，所以可能出现 key1 != key2，而hash(key1) == hash(key2)的情况。
>
> 常用的冲突解决方式有：`开放寻址法`和`链表法`。

**1. 开放寻址法（open addressing）**

出现了散列冲突，就重新探测一个空闲位置，将其插入。

* 所有数据都在数组中，内存是连续的，可以有效地利用 CPU 缓存加快查询速度。
* 序列化方便。
* 大数据量情况下更容易发生冲突：随数据越来越多，冲突将的可能性将递增，空闲位置越来越少，探测时间递增。最坏情况时间复杂度将退化为O(n)，适用于数据量较小的场景。
* 内存利用率低：更加容易发生冲突，装载因子不能设置过大，从而浪费内存空间。

> 线性探测（Linear Probing）：步长 hash(key) + n。
>
> Java 中的 ThreadLocalMap

插入数据：当往散列表中插入数据时，根据`散列值`找到数组对应位置，空闲则存入。若存储位置已被占用，则从当前位置依次往后开始查找，直到找到空闲位置。

查询数据：根据`散列值`找到数组对应位置，比较该位置的key是否匹配，匹配则返回。若不匹配就需要顺序往后依次查询并匹配key，如果遍历到空闲位置也没有找到，表示不在散列表中。

删除操作：由于线性探测的特性，查询时遍历到空闲位置会被认定数据不存在，所以被删除的元素会被`标记为deleted`，而不是直接删除。

> 二次探测（Quadratic probing）

类似线性探测，探测步长不同，步长为` hash(key) + n^2`

> 双重散列（Double hashing）

使用**一组散列函数**，若通过第一个函数得到的位置已被占用，则使用第二个散列函数，依次类推，直到找到空闲位置。

**2. 链表法（chaining）**

> Java 中的 HashMap，底层通过数组+链表+红黑树。
>
> LinkedHashMap

每个槽位对应一个链表。所有散列值相同的元素都放在相同槽位的链表中。

* 适用于大规模数据。
* 内存占用变多。不过对较小对象数据的存储，由于多出了结点指针，可能导致内存消耗翻倍。大对象数据时则可忽略影响。
* 内存不连续，对CPU缓存不友好。
* 需要尽可能让散列值均匀分布，防止时间复杂度退化。

> 散列表碰撞攻击
>
> 恶意的攻击者通过精心构造的数据，使得所有数据在散列函数计算后，都落到相同的槽中。此时散列表退化为链表，查询的时间复杂度变为O(n)，导致查询耗时大大增加，系统可能无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。
>
> 可以将链表改造为其他数据结构（例如跳表、红黑树等）进行优化，避免退化为O(n)。

##### 散列表的应用

* LRU缓存淘汰策略：散列表 + 双向链表
* Redis有序集合：跳表 + 散列表
* LinkedHashMap：散列表 + 双向链表，原理同LRU缓存淘汰策略。

### 1.2 树（Tree）

> 存储方式
>
> 1. 基于指针或者引用的二叉链式存储法。
>
> 2. 基于数组的顺序存储法。

A为**根节点**，它没有父节点。

A是B、E的**父节点**，BE互为**兄弟节点**。

CDE叫做**叶子节点（叶节点）**，它们没有字节点。

**后继节点：**比当前节点大的最小节点。

**前驱节点：**比当前节点小的最大节点。

* **节点的高度：**节点到叶子节点的**最长路径（边数**），例如 heightA = 2；heightB = 1。从上往下递减。
* **节点的深度：**根节点到节点的所经过的边数。depthA = 0；depthB = 1。从上往下递增。
* **节点的层数：**节点深度 + 1。levelA = 1；levelB = 2。从上往下递增。
* **树的高度：**等同 根节点的高度。此处为2。从上往下递减。

![树](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/%E6%A0%91.png)

#### 二叉树

>  每个节点**最多两个**子节点：左子节点和右子节点。

##### 满二叉树

> 特殊的完全二叉树

* 叶子节点都在最底层。
* 除叶子节点外，都有两个子节点。

##### 完全二叉树

* 叶子节点都在最后两层。
* 最后一层所有叶子节点都靠左排列（左对齐、连续）。
* 除最后一层外，其他层节点个数都达到最大。

##### 树的遍历

* **前序遍历**：对于树中任意节点，先打印这个**节点自身**，再打印左子树，最后打印**右子树**。
* **中序遍历**：对于树中任意节点，先打印**左子树**，再打印**节点自身**，最后打印**右子树**。
* **后序遍历**：对于树中任意节点，先打印**左子树**，再打印**右子树**，最后这个**节点自身**。

#### 二叉查找树（Binary Search Tree）

> 也叫作`二叉排序树`：由于左小右大，使用中序遍历，可以输出有序的数据序列。

特点

- **左子树**上的所有节点的值均**<=父节点**的值。
- **右子树**上的所有节点的值均**>=父节点**的值。
- 左右子树也为满足上述条件的二叉搜索树。

##### 查找

* 首先和根节点比较，如果相等直接返回。

* 若**数据比节点小**，则从**左子树中递归**搜索。

* 若**数据比节点大**，则从**右子树中递归**搜索。

##### 插入

* 执行查找流程

* 若**数据比节点大**且节点的**右子树为空**，则直接将新数据**插入右子节点**位置。若不为空，**则递归遍历右子树**，查找合适位置。
* 若**数据比节点小**且节点的**左子树为空**，则直接将新数据**插入左子节点**位置。若不为空，**则递归遍历左子树**，查找合适位置。

##### 删除

1. 需要删除的节点**没有子节点**：只需要将父节点中原本**指向删除子节点的指针置为null**。
2. **只有一个子节点**：将父节点中原本**指向删除子节点的子节点**。
3. **存在两个子节点：**找到删除子节点右子树中的最小节点，将它的数据替换到删除节点中，再删除这个最小节点。由于是最小节点，至多只有右节点，从原本位置中删除时参考前2条。**实质为 为前/后驱结点的数据交换 + 删除**。此处为后继结点删除。



> 时间复杂度

| 操作 | 最优 | 一般 | 最坏 |
| ---- | ---- | ---- | ---- |
| 查找 |      |      | O(N) |
| 插入 |      |      | O(N) |
| 删除 |      |      | O(N) |

> 查找操作



最坏场景：O(N)

>  插入 9、10、11

![image-20220530143106188](数据结构与算法.assets/image-20220530143106188-3892268.png)

>  旋转操作

- 左旋
- 右旋



#### 平衡树

> 保证左右子树高度差相对较小，解决在频繁的插入和删除中时间复杂度退化的问题。
>
> 最先被发明的平衡二叉查找树是`AVL 树`。

* 二叉树中任意一个节点的左右子树的高度相差不能大于1。
* 为了维持平衡插入、删除的代价提高。

| 时间复杂度 | 最优 | 一般    | 最坏 |
| ---------- | ---- | ------- | ---- |
| 查找       |      | O(logN) |      |
| 插入       |      | O(logN) |      |
| 删除       |      | O(logN) |      |



#### 234树/4阶B树

> 红黑树的前身

- 是一种多叉树。
- 每个节点最多有``3个数据项``和``4个子节点``。

![image-20220530143729600](数据结构与算法.assets/image-20220530143729600-3892651.png) 插入操作：``上溢``。

删除操作：``下溢``。



#### 红黑树（Red-Black Tree）

> 一种高效的自平衡二叉查找树。但是并不严格符合平衡二叉树的定义，而是近似平衡。
>
> 每个结点上增加一个存储位表示结点的颜色。
>
> 代码实现中可用一个哨兵代表NIL。

1. 节点是红色或黑色的。
2. 根节点是黑色。
3. 每个叶子节点NIL都是空的， 不存储数据（注意）。
4. 红色节点的父节点和子节点都为黑色(任何相邻的节点都不能同时为红色)。
5. 从任一节点到可达的叶子节点的所有路径都包含相同的数量的黑色节点（黑高相同）。

> 红黑树和234树是等价

- 红黑树的黑色节点个数 = 234树的节点数。（4、10、7是一个节点的三个数据项）
- 234树的每一个节点中：黑色节点必为父节点，红色节点为子节点（黑色在中间，红色在两边）。

![image-20220929225928693](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20220929225928693.png)


##### 树的变换
> 当红黑树平衡被打破时，通过**旋转**和**变色**恢复。
>
> 旋转操作对于二叉查找树来说**一般情况就是为了找到合适的中间值，并重新构建成二叉查找树**。

**变色**：红色节点变为黑色节点，黑色节点变为红色节点。

**左旋（rotate left**）：围绕某个点进行左旋（图中为绕1左旋）。 

![image-20220929210112940](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20220929210112940.png)

**右旋（rotate right）**：围绕某个点进行右旋（图中为绕1右旋）。

![image-20220929210153548](./%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20220929210153548.png)

##### 插入操作

* 红黑树规定，插入的节点必须是红色。插入红色不会影响黑高，仅需要处理两个红色结点相邻的场景。
* 如果插入的是根节点，直接变色为黑色。
* 其余情况插入的节点``最开始都一定是红色``（出现连续两个红色节点的冲突情况时需要进行旋转和变化）。

> 插入操作的12种情况，可以归纳为3类

- 插入节点的父节点为黑色（4种）：直接插入，不做调整。
- 插入节点的叔父节点不是红色（4种）：变色 + 旋转（单旋、双旋）。
  * LL：变色（父、祖父） + 右旋（绕祖父）。
  * RR：变色（父、祖父）+ 左旋（绕祖父）。
  * RL：变色（插入、祖父） + 父右旋（变为了RR） + 祖父左旋
  * LR：变色（插入、祖父） + 父左旋 （变为了LL）+ 祖父右旋
- 插入节点的叔父节点是红色（4种，对应234树的上溢）：只需要变色。

  1. 父、叔结点：改为黑色（黑高同时 + 1，保证局部平衡）。
2. 祖父结点：改为红色（黑高 - 1，从而保证整体平衡）。

##### 删除操作

* 红色节点直接删除。
* 黑色节点删除。
  * 删除节点有2个红色子节点。（根据前/后驱节点删除，将转化为子节点的删除）
  * 删除节点有1个红色子节点。（需要将子节点染为黑色）
  * 删除节点的子节点为黑色节点。（234的下溢处理）
    * 删除节点为根节点，直接删除。
    * 删除节点的兄弟节点为黑色（**A**）。
      * 兄弟节点有红色子节点。（旋转 + 变换，原理同插入中的LL/RR/LR/RL）
      * 兄弟节点没有红色子节点。（兄弟节点染红，父节点染黑，若父本来就为黑色，则使用父节点作为删除节点递归**A流程**）
    * 删除节点的兄弟节点为红色。（染为黑色后转为上述处理）

#### 递归树

> 分析递归算法的时间复杂度

* 将问题拆解为层层子问题
* 计算每一层的总时间
* 统计树高，累加

## 2 算法基础

### 2.1 复杂度分析

#### 时间复杂度

> 在小规模数据面前, O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。因为此时省略的低阶、系数和常数的影响将会放大。

* O(1)：常量级
* O(n)：线性复杂度
* O(n^2)：指数复杂度
* O(logn): 对数复杂度

#### 空间复杂度



### 2.2 排序算法

| 排序算法 | 时间复杂度                  | 空间复杂度 | 稳定排序？ | 原地排序？ |
| -------- | --------------------------- | ---------- | ---------- | ---------- |
| 冒泡排序 | O(n^2)                      |            | Y          | Y          |
| 插入排序 | O(n^2)                      |            | Y          | Y          |
| 选择排序 | O(n^2)                      |            | N          | Y          |
| 快速排序 | O(n logn), 最坏退化为O(n^2) | O(1)       | N          | Y          |
| 归并排序 | O(n logn)                   | O(n)       | Y          | N          |
| 计数排序 | O(n + k)，k是数据范围       |            | Y          | N          |
| 桶排序   | O(n)                        |            | Y          | N          |
| 基数排序 | O(d n), d是维度             |            | Y          | N          |

#### 插入排序

循环不变式
> 元素A[1..j-1]就是原来在位置1到j-1的元素，但已按序排列
- 初始化：循环的第一次迭代之前，它为真。
- 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。
- 终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法时正确的。

####  快速排序

> 分区选择优化

* 三数取中法；

  首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。数组比较大时，取数需要更多，5数、10数等。

* 随机法；

  随机选择一个元素作为分区点，每次都选中最差分区的情况不太可能出现。

> 递归优化

* 限制递归层级；

* 自己实现堆上栈；

  手动模拟递归，越过系统栈大小的限制；

### 2.3 查找

|          | 时间复杂度 |      |
| -------- | ---------- | ---- |
| 二分查找 | O(logn)    |      |
|          |            |      |
|          |            |      |

#### 二分查找（Binary Search）

> 折半查找算法
>
> 在链表中的`跳表`可以支持类似二分的查找算法

* 顺序表结构
* 有序数据集合

> 二分查找变形问题、

* 查找第一个值等于给定值的元素
* 查找最后一个值等于给定值的元素
* 查找第一个大于等于给定值的元素
* 查找最后一个小于等于给定值的元素

### 2.4 哈希（Hash）算法

> 将任意长度的二进制值串映射为固定长度的二进制值串。

#### 哈希算法的要求

* **单向推导：**从哈希值不能反推出原始数据（也叫单向哈希算法）。
* **数据敏感**：对于不同的输入数据，哪怕仅相差一个Bit，得到的哈希值也大不相同。
* **散列冲突概率低**：鸽巢原理
* **高效执行：**针对大量文本也能快速的计算出哈希值。

#### 哈希算法的应用

* 安全加密：例如 **MD5**（MD5 Message-Digest Algorithm，MD5 消息摘要算法）、**SHA**（Secure Hash Algorithm，安全散列算法）、**DES**（Data Encryption Standard，数据加密标准）、**AES**（Advanced Encryption Standard，高级加密标准）等。
* 唯一标识：例如图库搜索图片
* 数据校验
* 散列函数：偏向于数据的平均性和执行效率。
* 负载均衡：客户端IP计算哈希，并根据服务器数量取模分配。
* 数据分片：使用哈希对海量数据进行分片，多机分布式处理。类同负载均衡。
* 分布式存储：一致性哈希算法。

#### 一致性哈希算法

> 背景：在分布式缓存中，我们通过取模的方式将哈希值分布到不同服务器上，若此时需要进行扩容/缩容时，所有数据都需要重新计算哈希值。那么所有数据请求都会穿透缓存，直接请求数据库，可能出现雪崩效应，压垮数据库。

一致性哈希算法通过将**数据的哈希划分为n个区间（尽可能大）**，并将这些区间分配给m台设备管理，**每台负责`n/m`个区间**。当有新的设备加入时，只需要**将部分区间数据搬迁到新的设备**即可，不需要全部重新哈希计算。

## 附录

### 伪代码

- 缩进表示块结构。

- `while`、`for`与`repeat-until`等循环结构以及`if-else`等条件语句机构与C、C++、Java、Python和Pascal中的那些机构具有类似的解释。

  ```
  to：迭代递增
  downto：迭代递减
  by：指定增量， by 2
  ```

- 符号`//`表示该行后面部分为注释。

- 形如`i=j=e`的多重赋值将表达式e的值赋给变量`i`和`j`。

  ```
  j = e;
  i = j;
  ```

- 变量是局部给定过程的。若无显示说明，不使用全局变量。

- 数组元素通过`数组名[下标]`的形式来访问。

  ```
  A[i] 表示 数组A的第i个元素。
  .. 表示数组值的一个范围,
  A[1..j] 表示A的一个子数组。
  ```

- 复合数据通常被组织称``对象``,对象又由``属性``组成。

  ```
  . 后跟一个 属性名。例如：A.length
  我们把表示一个数组或对象的变量看作指向表示数组或对象的数据的一个指针。
  ```

- ``按值``把参数传递给过程：被调用过程接收其参数自身的副本。

  ```
  如果对某个参数赋值，调用过程看不到这种改变。即参数重新赋值对原始参数并没有影响。
  当对象被传递时，指向表示对象数据的指针被复制，而对象的属性并未被复制。即改变对象的属性时，原始对象内的属性也将会被改变。
  数组同对象。
  ```

- 一个`return`语句立即将控制返回到调用过程的调用点。

- 布尔运算符``and``和``or``都是**短路的**。
  x and y，若 x 为 false，则不再求值y。
  x or y，若 x 为 true， 则不再求值y。

- 关键词``error``表示因为已被调用的过程情况不对而出现了一个错误。


### 分析算法

#### RAM模型

假定为单处理器，指令一条接一条地执行，没有并发操作。

- 算术指令

  ```
  加法、减法、乘法、除法、其余、向下取整、向上取整
  ```

- 数据移动指令

  ```
  装入、存储、复制
  ```

- 控制指令

  ```
  条件与无条件转移、子程序调用与返回
  ```

---

## 
