# 数据结构与算法

## 复杂度分析

时间复杂度

* O(1)：常量级
* 

## 数据结构

### 1. 线性表
#### 1.1 数组和矩阵

> 连续空间

优点

- 存取速度快

缺点

- 需要事先设置数组的长度。
- 需要连续的大块内存，且大小固定。
- 插入/删除节点慢。


#### 1.2 链表

优点

- 插入删除速度快。
- 空间没有限制，也不必事先知道大小。

缺点
- 存取速度慢。

链表的类型：

- 单向链表：一个节点指向下一个节点。

- 双向链表：一个节点有2个指针域。
    ```
    
    ```
    
- 循环链表：链表的最后一个节点指向第一个节点。
    ```
    能通过任意一个节点找到所有的节点。
    ```



### 2. 树

#### 二叉搜索树

特点

- 左子树上的所有节点的值均<=父节点的值。
- 右子树上的所有节点的值均>=父节点的值。
- 左右子树也为满足上述条件的二叉搜索树。



> 时间复杂度

| 操作 | 最优 | 一般 | 最坏 |
| ---- | ---- | ---- | ---- |
| 查找 |      |      | O(N) |
| 插入 |      |      | O(N) |
| 删除 |      |      | O(N) |



最坏场景：O(N)

>  插入 9、10、11

![image-20220530143106188](数据结构与算法.assets/image-20220530143106188-3892268.png)

##### 旋转操作

- 左旋
- 右旋



#### 平衡树

> 时间复杂度

| 操作 | 最优 | 一般    | 最坏 |
| ---- | ---- | ------- | ---- |
| 查找 |      | O(logN) |      |
| 插入 |      | O(logN) |      |
| 删除 |      | O(logN) |      |



#### 234树/4阶B树

- 是一种多叉树
- 每个节点最多有``3个数据项``和``4个字节点``。

![image-20220530143729600](数据结构与算法.assets/image-20220530143729600-3892651.png) 插入操作：``上溢``。

删除操作：``下溢``。



#### 红黑树

> 一种高效的自平衡二叉搜索树

- 节点是红色或黑色。
- 根节点是黑色。
- 叶子节点都为黑色，且都为空。
- 红色节点的父节点和字节点都为黑色(不会存在2个连续的红色节点)。
- 从任一节点到叶子节点到所有路径都包含相同的数量的黑色节点。

> 红黑树和234树是等价

- 红黑树的黑色节点个树 = 234树的节点数
- 234树的每一个节点中：黑色节点必为父节点，红色节点为字节点（黑色终结，红色两边）。



##### 插入操作的12种情况

> 如果插入的是根节点，则为黑色。
>
> 其余情况插入的节点``最开始都一定是红色``（出现连续两个红色节点的冲突情况时需要进行旋转和变化）。

- 插入节点的父节点为黑色（4种）：直接插入，不做调整。
- 叔父节点不是红色（4种）：变色 + 旋转。
- 叔父节点时红色（4种上溢）：变色。




## 伪代码

- 缩进表示块结构。
- while、for与repeat-until等循环结构以及if-else等条件语句机构与C、C++、Java、Python和Pascal中的那些机构具有类似的解释。

    ```
    to：迭代递增
    downto：迭代递减
    by：指定增量， by 2
    ```
- 符号``//``表示该行后面部分为注释。
- 形如i=j=e的多重赋值将表达式e的值赋给变量i和j。

    ```
    j = e;
    i = j;
    ```

- 变量是局部给定过程的。若无显示说明，不使用全局变量。
- 数组元素通过``数组名[下标]``的形式来访问。

    ```
    A[i] 表示 数组A的第i个元素。
    .. 表示数组值的一个范围,
    A[1..j] 表示A的一个子数组。
    ```
- 复合数据通常被组织称``对象``,对象又由``属性``组成。
    ```
    . 后跟一个 属性名。例如：A.length
    我们把表示一个数组或对象的变量看作指向表示数组或对象的数据的一个指针。
    ```

- ``按值``把参数传递给过程：被调用过程接收其参数自身的副本。
    ```
    如果对某个参数赋值，调用过程看不到这种改变。即参数重新赋值对原始参数并没有影响。
    当对象被传递时，指向表示对象数据的指针被复制，而对象的属性并未被复制。即改变对象的属性时，原始对象内的属性也将会被改变。
    数组同对象。
    ```
- 一个reutrn语句立即将控制返回到调用过程的调用点。
- 布尔运算符``and``和``or``都是**短路的**。
    ```
    即 x and y，若 x 为 false，则不再求值y。
    x or y，若 x 为 true， 则不再求值y。
    ```
- 关键词``error``表示因为已被调用的过程情况不对而出现了一个错误。


## 分析算法

### RAM模型
假定为单处理器，指令一条接一条地执行，没有并发操作。

- 算术指令
    ```
    加法、减法、乘法、除法、其余、向下取整、向上取整
    ```

- 数据移动指令
    ```
    装入、存储、复制
    ```

- 控制指令
    ```
    条件与无条件转移、子程序调用与返回
    ```

## 算法基础

### 1. 排序

| 排序算法 | 时间复杂度                  | 稳定排序？ | 原地排序？ |
| -------- | --------------------------- | ---------- | ---------- |
| 冒泡排序 | O(n^2)                      | Y          | Y          |
| 插入排序 | O(n^2)                      | Y          | Y          |
| 选择排序 | O(n^2)                      | N          | Y          |
| 快速排序 | O(n logn), 最坏退化为O(n^2) | N          | Y          |
| 归并排序 | O(n logn)                   | Y          | N          |
| 计数排序 | O(n + k)，k是数据范围       | Y          | N          |
| 桶排序   | O(n)                        | Y          | N          |
| 基数排序 | O(d n), d是维度             | Y          | N          |

#### 1.1 插入排序

循环不变式
> 元素A[1..j-1]就是原来在位置1到j-1的元素，但已按序排列
- 初始化：循环的第一次迭代之前，它为真。
- 保持：如果循环的某次迭代之前它为真，那么下次迭代之前它仍为真。
- 终止：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法时正确的。

### 1.2 快速排序

> 分区选择优化

* 三数取中法；

  首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。数组比较大时，取数需要更多，5数、10数等。

* 随机法；

  随机选择一个元素作为分区点，每次都选中最差分区的情况不太可能出现。

> 递归优化

* 限制递归层级；
* 手动模拟函数调用栈，越过系统栈大小的限制；
