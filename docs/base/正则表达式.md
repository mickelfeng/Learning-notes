# 正则表达式

[正则表达式30分钟入门教程_脚本之家 (jb51.net)](https://www.jb51.net/tools/zhengze.html)

## 元字符表：

| 元字符 |                                           |                              |
| ------ | ----------------------------------------- | ---------------------------- |
| .      | 除换行符以外的任意字符。                  |                              |
| ^      | 匹配字符是否是``字符串的开始位置``。      | 定位                         |
| $      | 匹配字符是否是``字符串的结束位置``。      | 定位                         |
| \w     | 匹配``字母、数字、下划线、汉字``。        |                              |
| \s     | 匹配``任意的空白符``(空格、Tab、换行等)。 |                              |
| \b     | 匹配``单词的开头或结尾``。                | \bhello\b， 匹配 hello  单词 |
| \d     | 匹配``数字``。                            |                              |

## 反义表

> 和元字符表想对应：变为大写，语义相反。

| 反义代码 |                                                  |      |
| -------- | ------------------------------------------------ | ---- |
| \W       | 匹配任意不是``字母、数字、下划线、汉字``的字符。 |      |
| \S       | 匹配任意不是空白符的字符。                       |      |
| \D       | 匹配任意非数字的字符。                           |      |
| \B       | 匹配不是单词开头或结束的位置。                   |      |
| [^x]     | 匹配除x以外的任意字符                            |      |
|          |                                                  |      |



## 限定符表

| 限定符 |                                          |      |
| ------ | ---------------------------------------- | ---- |
| *      | 表示前面的内容重复任意次数,`` >= 0次``。 |      |
| +      | 重复``>=1次``。                          |      |
| ?      | 重复``0次或1次``。                       |      |
| {n}    | 重复``n次``。                            |      |
| {n,}   | 重复``>=n次``。                          |      |
| {n,m}  | 重复``n到m次``。                         |      |
| *?     | 重复``>=0次``，但是尽可能少的重复。      |      |
| +?     | 重复``>=1次``，但是尽可能少的重复。      |      |
| ??     | 重复``0次或者1次``，但是尽可能少的重复。 |      |
|        |                                          |      |

## 分组

> 使用小括号进行分组，以左括号为标志。
>
> 从左到右组号依次递增，1、2、3、N。
>
> 0表示的是整串匹配到的内容。 

### 捕获

|      | 代码           |                                              |      |
| ---- | -------------- | -------------------------------------------- | ---- |
|      | (exp)          | 匹配exp,并将匹配内容捕获到自动分组中。       |      |
|      | (?\<name\>exp) | 匹配exp,并将匹配内容捕获到名为name的分组中。 |      |
|      | (?:exp)        | 仅匹配，不分组，也不捕获内容到分组中。       |      |
|      |                |                                              |      |
| 注释 | (?#comment)    | 不参数正则匹配                               |      |

### 零宽断言

| 零宽断言         | 语法     |                                         |                           |
| ---------------- | -------- | --------------------------------------- | ------------------------- |
| 零宽正向先行断言 | (?=exp)  | 断言自身出现的位置的后面能匹配表达式exp | 即匹配表达式exp前面的位置 |
| 零宽正向后行断言 | (?<=exp) | 断言自身出现的位置的前面能匹配表达式exp |                           |
| 零宽负向先行断言 | (?!exp)  | 断言此位置的后面不能匹配表达式exp       |                           |
| 零宽负向后行断言 | (?<!exp) | 断言此位置的前面不能匹配表达式exp       |                           |

## 分支条件

> 使用 	``|`` 将不同的规则分割开。满足任意一种即匹配成功。

## demo

> matcher方法

```kotlin
fun matcher(content: String, pattern: Pattern) {
    val matcher = pattern.matcher(content)
    MyLog.i("matcher", "--------------------- start matcher ---------------------")
    MyLog.i("matcher", "pattern content: ${content};")
    MyLog.i("matcher", "pattern pattern: ${pattern};")
     MyLog.i("matcher", "pattern matches: ${matcher.matches()};") // matches整段内容完全匹配才返回true
    // matches() 和 find() 都会改变内部的匹配位置。需要reset()一下。
    matcher.reset()
    while (matcher.find()) { // 找到符合条件的就返回，然后继续往下找，直到结束
        val start = matcher.start()
        val end = matcher.end()
        MyLog.i("matcher", "find $start-$end; ${matcher.group()}")
    }
    MyLog.i("matcher", "--------------------- end matcher ---------------------")
}

```



>  \b

```kotlin
// find start: 7; end: 12
// \b匹配的是单词，所以需要分隔符才符合匹配规则
fun patternWord() {
    val content = "hello1 hello 11hello"
    val matchWord = "hello"
    matcher(content, "\\b$matchWord\\b".toPattern())
}

```

