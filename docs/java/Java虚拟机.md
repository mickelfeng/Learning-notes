# Java虚拟机

# 参考资料

> **深入理解Java虚拟机（第3版）**📚

# 概述

## 什么是JVM?

首先是字面意思: Java虚拟机(Java Virtual Machine)。

JVM屏蔽了与具体平台相关的信息，通过在真实的计算机上仿真模拟各种计算机的功能。

**JVM本质上还是一个程序**，它制定了一种用于计算设备的规范。任何平台只需要装上该平台的Java虚拟机，就能使得已编译好的字节码文件(.class)在该平台上不加修改的运行。也就是``Compile Once,Run AnyWhere``。

## Java虚拟机家族:

| JVM                   | 备注                                                         |
| --------------------- | ------------------------------------------------------------ |
| Sun Classic VM        | **世界第一款商用Java虚拟机。**<br />纯解释器方式执行。<br />可以外挂即时编译器,不过此时解释器便不再工作。<br />JDK1.0时搭载, 从JDK 1.2开始和HotSpot 共存, 直至1.4完全退出商用虚拟机的历史舞台。<br />基于Handle的对象查找方式。 |
| Exact VM              | JDK1.2版本时在Solaris平台上发表过, 后未普及就被HotSpot Vm替代。<br />采用准确式内存管理,可以知道内存中某个位置的数据具体时什么类型。<br />热点探测、编译器和解释器混合工作等。 |
| **HotSpot VM**        | Sun公司收购后，从JDK1.2开始搭载。<br />**全世界使用最广泛的虚拟机**<br />准确式内存管理、热点代码探测技术、编译器和解释协同工作等。 |
| BEA JRockit           | 后被Oracle收购，不再发展, HotSport从中吸取了部分功能，如Java Mission Control监控工具。 |
| **IBM J9**            |                                                              |
| Mobile/Embedded VM    |                                                              |
| BEA Liquid VM/Azul VM | 专有虚拟机:与特定硬件平台绑定、软硬件配合。                  |
| Apache Harmony        | 非华为的Harmony OS。😂<br />它的许多代码被吸纳进Google Android SDK中。 |
| Dalvik虚拟机          | **并不是一个Java虚拟机，但和Java存在千丝万缕的关系。**<br />它没有遵循《Java虚拟机规范》，不能直接执行Java的Class文件，使用寄存器架构而不是Java虚拟机中常见的栈架构。<br />Android 5.0 开始ART(支持AOT提前编译)全面替代了Dalvik虚拟机。 |
| 一些非主流Java虚拟机  | KVM、Java Card VM、Squawk VM等等。                           |



# JVM主要模块划分

类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块

# 运行时数据区域

## ① 程序计数器

> **线程私有**、**生命周期和线程绑定**。
>
> 程序控制流的指示器: 记录当前线程执行的**字节码的行号指示器**。
>
> Java虚拟机规范中唯一没有规定OOM的区域。
>
> Program Counter Register 原来你也叫PCR啊🤣，打开PCR摸鱼去了

字节码解释器工作时通过修改计数器的值来选择下一条需要执行的字节码指令。

每条线程都有一个独立的程序计数器, 各线程之间计数器互不影响，保证``线程切换时能够恢复到正确的执行位置``。

由于主要是用来记录线程执行位置的，所以线程结束后，程序计数器也就不再存在，``生命周期和线程绑定``。

具体记录的内容:

- 若正在执行Java方法：正在执行的虚拟机字节码指令地址。

- 若正在执行Native方法：计数器值为空（Undefinded）。

## ② Java虚拟机栈

> **线程私有**、**生命周期和线程绑定**。
>
> 虚拟机栈描述的是**Java方法执行的线程内存模型**。
>
> ``StackOverflowError``
>
> - 线程请求的栈深度大于虚拟机所允许的升深度时抛出。
>
> ``OutOfMemoryError``
>
> - Java虚拟机栈容量可动态拓展(Classic)：无法申请足够内存时抛出。
> - Java虚拟机栈容量不可动态拓展(HotSpot)：线程申请栈空间失败时抛出。

Java虚拟机不是真实的物理机，它没有寄存器，所以指令集是使用Java栈来存储中间数据。

java内存区域当中常说的``堆栈``中的``栈``通常就是指虚拟机栈，更多情况只是指虚拟机栈中的局部变量表。

### 栈帧

每一个方法被调用直至结束的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。

``方法开始执行`` = ``栈帧入栈``

``方法执行完毕`` = ``栈帧出栈``

每个方法被执行的时候，Java虚拟机栈都会同步创建一个栈帧用于存储信息。

栈帧中信息主要有:

#### **局部变量表** 

> **所需的内存空间在编译期间完成分配**。进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间时完全确定的，且**在方法运行期间不会改变局部变量表的大小**(变量槽Slot的数量)。
>
> 一个局部变量槽Slot占32还是64bit是由虚拟机决定的。

| 类型              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| 基本数据类型      | 编译期可知的各种Java虚拟机基本数据类型boolean、byte、 char、 short、 int、 float、 long、 double。 |
| 对象引用          | reference类型不等同于对象本身，可能是指向对象起始地址的引用指针，也可能是代表对象的句柄或其他于此对象相关的位置。 |
| returnAddress类型 | 指向了一条字节码指令的地址                                   |

**✨注意点:**

1. 对象引用存放在栈中的局部变量表中，具体对象是存储在堆上的。
2. 基础类型是直接存储在栈中的局部变量表的。``包装类是对象所以引用和值是分开存的如上一条。``

#### 动态连接

#### 方法出口

#### 操作数栈

