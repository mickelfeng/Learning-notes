## Android热修复



### dex命令位置

`` ../Android/sdk/build-tools/xxxx/dx ``



### 1. 打包jar

`` jar cvf path.jar ydc/hotfix/BugClass.class ``


### 2. 做成补丁包path_dex.jar


再把path.jar做成补丁包path_dex.jar，只有通过dex工具打包而成的文件才能被Android虚拟机(dexopt)执行。
依然在该路径下执行以下命令:

`` dx --dex --output=path_dex.jar path.jar ``


### 3. 拷贝path_dex

我们把path_dex文件拷贝到assets目录下


### 4. 开始打补丁

- 创建一个私有目录，并把补丁包文件写入到该目录下
- path_dex插入到上面提到的装有dex的有序数组dexElements的最前面patch方法中的代码如下

```
public static void patch(Context context, String patchDexFile, String patchClassName) {
        if (patchDexFile != null && new File(patchDexFile).exists()) {
            try {
                if (hasLexClassLoader()) {
                    injectInAliyunOs(context, patchDexFile, patchClassName);
                } else if (hasDexClassLoader()) {
                    injectAboveEqualApiLevel14(context, patchDexFile, patchClassName);
                } else {

                    injectBelowApiLevel14(context, patchDexFile, patchClassName);

                }
            } catch (Throwable th) {
            }
        }
    }
    
    //
    private static boolean hasDexClassLoader() {
      try {
          Class.forName("dalvik.system.BaseDexClassLoader");
          return true;
      } catch (ClassNotFoundException e) {
          return false;
      }
  }
  
  //
  
  private static void injectAboveEqualApiLevel14(Context context, String str, String str2)
        throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        PathClassLoader pathClassLoader = (PathClassLoader) context.getClassLoader();
        Object a = combineArray(getDexElements(getPathList(pathClassLoader)),
            getDexElements(getPathList(
                new DexClassLoader(str, context.getDir("dex", 0).getAbsolutePath(), str, context.getClassLoader()))));
        Object a2 = getPathList(pathClassLoader);
        setField(a2, a2.getClass(), "dexElements", a);
        pathClassLoader.loadClass(str2);
    }

```
